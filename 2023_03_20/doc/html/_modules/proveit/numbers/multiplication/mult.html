
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>proveit.numbers.multiplication.mult &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<header>These are archival webpages, generated on 2023-03-20 by <a href="https://github.com/sandialabs/Prove-It">Prove-It</a> Beta Version 0.3, licensed under the GNU Public Licence by Sandia Corporation.  See <a href="http://pyproveit.org">pyproveit.org</a> for the lastest version.</header>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit.numbers.multiplication.mult</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="p">(</span>
        <span class="n">defaults</span><span class="p">,</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">,</span> 
        <span class="n">Judgment</span><span class="p">,</span> <span class="n">ProofFailure</span><span class="p">,</span> <span class="n">UnsatisfiedPrerequisites</span><span class="p">,</span>
        <span class="n">prover</span><span class="p">,</span> <span class="n">relation_prover</span><span class="p">,</span> <span class="n">equality_prover</span><span class="p">,</span>
        <span class="n">auto_prover</span><span class="p">,</span> <span class="n">auto_relation_prover</span><span class="p">,</span> <span class="n">auto_equality_prover</span><span class="p">,</span>
        <span class="n">SimplificationDirectives</span><span class="p">,</span> <span class="n">TransRelUpdater</span><span class="p">,</span> <span class="n">free_vars</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">And</span><span class="p">,</span> <span class="n">Equals</span><span class="p">,</span> <span class="n">NotEquals</span><span class="p">,</span> <span class="n">is_irreducible_value</span><span class="p">,</span> <span class="n">EvaluationError</span><span class="p">,</span> 
    <span class="n">InSet</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">NumberOperation</span><span class="p">,</span> <span class="n">deduce_number_set</span><span class="p">,</span>
    <span class="n">readily_provable_number_set</span><span class="p">,</span> <span class="n">standard_number_set</span><span class="p">,</span> 
    <span class="n">is_numeric_natural</span><span class="p">,</span> <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">is_numeric_rational</span><span class="p">,</span>
    <span class="n">standard_number_sets</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.numbers.number_sets</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ZeroSet</span><span class="p">,</span> <span class="n">Natural</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">,</span>
    <span class="n">Integer</span><span class="p">,</span> <span class="n">IntegerNonZero</span><span class="p">,</span> <span class="n">IntegerNeg</span><span class="p">,</span> <span class="n">IntegerNonPos</span><span class="p">,</span>
    <span class="n">Rational</span><span class="p">,</span> <span class="n">RationalNonZero</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span> <span class="n">RationalNeg</span><span class="p">,</span> <span class="n">RationalNonNeg</span><span class="p">,</span>
    <span class="n">RationalNonPos</span><span class="p">,</span>
    <span class="n">Real</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">,</span>
    <span class="n">Complex</span><span class="p">,</span> <span class="n">ComplexNonZero</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">proveit.numbers.numerals.decimals</span>
<span class="kn">from</span> <span class="nn">proveit.numbers.numerals.decimals</span> <span class="k">import</span> <span class="n">DIGITS</span>
<span class="kn">from</span> <span class="nn">proveit.abstract_algebra.generic_methods</span> <span class="k">import</span> <span class="p">(</span>
        <span class="n">apply_commutation_thm</span><span class="p">,</span> <span class="n">apply_association_thm</span><span class="p">,</span> <span class="n">apply_disassociation_thm</span><span class="p">,</span>
        <span class="n">group_commutation</span><span class="p">,</span> <span class="n">pairwise_evaluation</span><span class="p">,</span>
        <span class="n">deduce_equality_via_commutation</span><span class="p">,</span> <span class="n">generic_permutation</span><span class="p">,</span>
        <span class="n">sorting_and_combining_like_operands</span><span class="p">,</span> <span class="n">sorting_operands</span><span class="p">,</span>
        <span class="n">multi_disassociation</span><span class="p">)</span>

<div class="viewcode-block" id="Mult"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult">[docs]</a><span class="k">class</span> <span class="nc">Mult</span><span class="p">(</span><span class="n">NumberOperation</span><span class="p">):</span>
    <span class="c1"># operator of the Mult operation.</span>
    <span class="n">_operator_</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">string_format</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span>  <span class="n">latex_format</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\cdot&#39;</span><span class="p">,</span>
                         <span class="n">theory</span><span class="o">=</span><span class="vm">__file__</span><span class="p">)</span>

    <span class="n">_simplification_directives_</span> <span class="o">=</span> <span class="n">SimplificationDirectives</span><span class="p">(</span>
            <span class="n">ungroup</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">combine_numeric_rationals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">combine_numeric_rational_exponents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">combine_all_exponents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">distribute_numeric_rational</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">distribute_fractions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># By default, sort such that numeric, rationals come first </span>
            <span class="c1"># but otherwise maintain the original order.</span>
            <span class="n">order_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">factor</span> <span class="p">:</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Multiply together any number of operands from first operand.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">NumberOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_operator_</span><span class="p">,</span> <span class="n">operands</span><span class="p">,</span>
                                 <span class="n">styles</span><span class="o">=</span><span class="n">styles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

    <span class="k">def</span> <span class="nf">_build_canonical_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a form of this Mult with operands in their canonical</span>
<span class="sd">        forms, nested multiplication is ungrouped, literal rational </span>
<span class="sd">        factors are pulled to the front and turned into an irreducible </span>
<span class="sd">        coefficient, &quot;common&quot; factors that are the same up to literal,</span>
<span class="sd">        rational exponents are combined, and these factors are</span>
<span class="sd">        deterministically sorted according to hash values of the</span>
<span class="sd">        exponential factor bases.  If, after pulling out the </span>
<span class="sd">        &#39;constants&#39; and combining exponents, there is only one </span>
<span class="sd">        non-constant factor that remains, and this factor is an Add </span>
<span class="sd">        expression, distribute the constant through; that is,</span>
<span class="sd">            (2/3) * (a + b + c)  -&gt;  (2/3)*a + (2/3)*b + (2/3)*c.</span>
<span class="sd">            </span>
<span class="sd">            [x * ((1/2)*y + ((2*z1)*(3*z2)*z3))] * 2</span>
<span class="sd">            </span>
<span class="sd">        Example:  (a/b)^{2/3) * c * (-2) * (a/b)^{-1/4} * c * (1/3) * d </span>
<span class="sd">            -&gt;    (-2/3) * a^{5/12} * b^{-5/12} * c^2  * d</span>
<span class="sd">        The order of the factors is arbitrary but deterministic</span>
<span class="sd">        (sorted by hash value) except the literal rational coefficient</span>
<span class="sd">        will be the first factor (or omitted if it is 1).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">Neg</span><span class="p">,</span> <span class="n">Exp</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> 
                                     <span class="n">simplified_numeric_rational</span><span class="p">)</span>
        <span class="c1"># Extract the literal rational factors from the rest.</span>
        <span class="c1"># Generate canonical forms of factors and ungroup nested</span>
        <span class="c1"># multiplications.</span>
        <span class="k">def</span> <span class="nf">gen_factors</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
                <span class="n">canonical_factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canonical_factor</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">sub_factor</span> <span class="ow">in</span> <span class="n">gen_factors</span><span class="p">(</span><span class="n">canonical_factor</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">sub_factor</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">canonical_factor</span>
        <span class="c1"># Populate base_to_exponent and extracted coefficient</span>
        <span class="c1"># numerator/denominator from the generated factors.</span>
        <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">base_to_exponent</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">gen_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="n">numer</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="n">numer</span> <span class="o">*=</span> <span class="n">factor</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="n">numer</span> <span class="o">*=</span> <span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
                <span class="n">denom</span> <span class="o">*=</span> <span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
                    <span class="n">exponent</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exponent</span> <span class="o">=</span> <span class="n">one</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">factor</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="c1"># canonicalize the base</span>
                <span class="k">if</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">base_to_exponent</span><span class="p">:</span>
                    <span class="n">prev_exponent</span> <span class="o">=</span> <span class="n">base_to_exponent</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prev_exponent</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                        <span class="n">exponent</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">prev_exponent</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> 
                                       <span class="n">exponent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">exponent</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">prev_exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
                <span class="n">base_to_exponent</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">exponent</span>
        <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Division by zero; the expression is garbage</span>
            <span class="k">raise</span> <span class="bp">self</span> <span class="c1"># we can&#39;t do anything with it.</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">simplified_numeric_rational</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
        <span class="c1"># Obtain the sorted, combined, canonical factors.</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_to_exponent</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
            <span class="c1"># Canonize the exponentiated factor.</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="n">base_to_exponent</span><span class="p">[</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># x^0 = 1</span>
            <span class="k">elif</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="c1"># Return the appropriate canonical form.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coef</span>
        <span class="k">if</span> <span class="n">coef</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span> <span class="c1"># 0*x = 0</span>
        <span class="k">if</span> <span class="n">coef</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">factors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># A single factor; if it is an Add, distribute the coef.</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mult</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="k">for</span> <span class="n">term</span>
                             <span class="ow">in</span> <span class="n">factor</span><span class="o">.</span><span class="n">terms</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Mult</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="o">*</span><span class="n">factors</span><span class="p">)</span>

<div class="viewcode-block" id="Mult.deduce_in_number_set"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.deduce_in_number_set">[docs]</a>    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_in_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove that this product is in the given number_set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.multiplication</span> <span class="k">as</span> <span class="nn">mult_pkg</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;number_set&#39;</span><span class="p">):</span>
            <span class="n">number_set</span> <span class="o">=</span> <span class="n">number_set</span><span class="o">.</span><span class="n">number_set</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">standard_number_sets</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;Mult.deduce_in_number_set()&#39; not implemented for the &quot;</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> set&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">number_set</span><span class="p">))</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">num_operand_entries</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
        <span class="n">thm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">operands</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ZeroSet</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_in_zero_set_bin</span>
            <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Integer</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_closure_bin</span>
            <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_closure_bin</span>
            <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Real</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_closure_bin</span>
            <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Complex</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_complex_closure_bin</span>
            <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ComplexNonZero</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_complex_nonzero_closure_bin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need more operand-specific infomation.</span>
                <span class="n">a_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span>
                <span class="n">b_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_pos_from_double_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_pos_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Natural</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_from_double_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">IntegerNeg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_neg_from_left_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_neg_from_right_neg</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">IntegerNonPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_nonpos_from_left_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_nonpos_from_right_nonpos</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_pos_from_double_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_pos_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonNeg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonneg_from_double_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonneg_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNeg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_neg_from_left_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_neg_from_right_neg</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonpos_from_left_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonpos_from_right_nonpos</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_pos_from_double_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_pos_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonNeg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">b_ns</span><span class="p">)):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonneg_from_double_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonneg_closure_bin</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNeg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_neg_from_left_neg</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_neg_from_right_neg</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">a_ns</span><span class="p">):</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonpos_from_left_nonpos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonpos_from_right_nonpos</span>
            <span class="k">if</span> <span class="n">thm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Case not handled: </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
        
        <span class="c1"># Not a simple binary operation.</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ZeroSet</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_in_zero_set</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Integer</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Natural</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Real</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Complex</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_complex_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ComplexNonZero</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_complex_nonzero_closure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We need more operand-specific infomation.</span>
            <span class="n">operand_ns_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">for</span>
                              <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">num_operand_entries</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">singular_membership</span> <span class="o">=</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">number_set</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unary_reduction</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">reduction</span><span class="o">.</span><span class="n">sub_left_side_into</span><span class="p">(</span>
                    <span class="n">singular_membership</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">number_set</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">NaturalPos</span><span class="p">,</span> <span class="n">IntegerNonZero</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span>
                <span class="n">RationalNonNeg</span><span class="p">,</span> <span class="n">RationalNonZero</span><span class="p">,</span>
                <span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">number_set</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">operand_ns</span><span class="p">)</span> <span class="k">for</span> 
                            <span class="n">operand_ns</span> <span class="ow">in</span> <span class="n">operand_ns_set</span><span class="p">)):</span>
            <span class="c1"># Not the simple case, so break this down via</span>
            <span class="c1"># association to be dealt with at a binary level where</span>
            <span class="c1"># necessary.</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span>
                   <span class="n">operands</span><span class="p">):</span>
                <span class="c1"># If there are any ExprRanges, wrap them in Mult.</span>
                <span class="c1"># and prove the number set membership in that</span>
                <span class="c1"># manner.</span>
                <span class="n">range_locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">operand</span> 
                                   <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)]</span>
                <span class="n">wrapped_operands</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">Mult</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)</span>
                        <span class="k">else</span> <span class="n">operand</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
                <span class="n">mult_wrapped</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">wrapped_operands</span><span class="p">)</span>
                <span class="c1"># Make a replacement to convert from the wrapped</span>
                <span class="c1"># operand version to the original.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">mult_wrapped</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">range_locations</span><span class="p">:</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No ExprRanges.  Use a divide and conquer strategy.</span>
                <span class="k">assert</span> <span class="n">num_operand_entries</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">num_operand_entries</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">mult_wrapped</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> 
                                        <span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">replacement</span> <span class="o">=</span> <span class="n">mult_wrapped</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mult_wrapped</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span>
                            <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">[:</span><span class="n">num_operand_entries</span><span class="o">//</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">[</span><span class="n">num_operand_entries</span><span class="o">//</span><span class="mi">2</span><span class="p">:]))</span>
                    <span class="n">replacement</span> <span class="o">=</span> <span class="n">mult_wrapped</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span>
                            <span class="mi">1</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">replacement</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="n">apply_transitivity</span><span class="p">(</span>
                            <span class="n">replacement</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span>
                                    <span class="mi">0</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="c1"># With a wrapped version and a replacement, we solve a</span>
            <span class="c1"># reduced problem to solve this one.</span>
            <span class="n">wrapped_membership</span> <span class="o">=</span> <span class="n">mult_wrapped</span><span class="o">.</span><span class="n">deduce_in_number_set</span><span class="p">(</span>
                    <span class="n">number_set</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">replacement</span><span class="o">.</span><span class="n">sub_right_side_into</span><span class="p">(</span>
                    <span class="n">wrapped_membership</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_nat_pos_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">IntegerNonZero</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_int_nonzero_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_pos_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonNeg</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonneg_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonZero</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_rational_nonzero_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealPos</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_pos_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonNeg</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonneg_closure</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonZero</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">mult_pkg</span><span class="o">.</span><span class="n">mult_real_nonzero_closure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsatisfiedPrerequisites</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to prove </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">operands</span><span class="o">.</span><span class="n">num_elements</span><span class="p">(),</span>
                                <span class="n">a</span><span class="p">:</span> <span class="n">operands</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the most restrictive number set we can readily</span>
<span class="sd">        prove contains the evaluation of this number operation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.number_operation</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">major_number_set</span><span class="p">,</span> <span class="n">union_number_set</span><span class="p">)</span>
        <span class="n">number_set_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">):</span> <span class="n">NaturalPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">):</span> <span class="n">IntegerNeg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">):</span> <span class="n">Natural</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">):</span> <span class="n">IntegerNonPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">):</span> <span class="n">IntegerNonZero</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span> <span class="n">Integer</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">):</span> <span class="n">RationalPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">):</span> <span class="n">RationalNeg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">):</span> <span class="n">RationalNonNeg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">):</span> <span class="n">RationalNonPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">):</span> <span class="n">RationalNonZero</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span> <span class="n">Rational</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">):</span> <span class="n">RealPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">):</span> <span class="n">RealNeg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">):</span> <span class="n">RealNonNeg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">):</span> <span class="n">RealNonPos</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">):</span> <span class="n">RealNonZero</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Real</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span> <span class="n">Real</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Complex</span><span class="p">,</span> <span class="n">ComplexNonZero</span><span class="p">):</span> <span class="n">ComplexNonZero</span><span class="p">,</span>
            <span class="p">(</span><span class="n">Complex</span><span class="p">,</span> <span class="n">Complex</span><span class="p">):</span> <span class="n">Complex</span>
        <span class="p">}</span>
        
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">if</span> <span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NaturalPos</span> <span class="c1"># [*]() = 1</span>
        <span class="k">elif</span> <span class="n">factors</span><span class="o">.</span><span class="n">is_single</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">major_number_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># If we stay Real, this will keep track of the relation to zero:</span>
        <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
            <span class="n">factor_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">factor_ns</span> <span class="o">==</span> <span class="n">ZeroSet</span><span class="p">:</span>
                <span class="c1"># If any factor is zero, the entire product (if it is</span>
                <span class="c1"># valid) is zero.</span>
                <span class="k">return</span> <span class="n">ZeroSet</span>
            <span class="n">major_number_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">major_number_set</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">zero_relation_number_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">factor_ns</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealPos</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNeg</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNeg</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealPos</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">RealNonNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">RealNonNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonNeg</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonPos</span>
                    <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">RealNonNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonPos</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonNeg</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">RealNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">RealNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonZero</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">Real</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">ComplexNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">zero_relation_number_set</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ComplexNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">factor_ns</span><span class="p">):</span>
                    <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">ComplexNonZero</span>
                    <span class="k">continue</span>
            <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">Complex</span>

        <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">union_number_set</span><span class="p">(</span><span class="o">*</span><span class="n">major_number_sets</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">major_number_set</span> <span class="o">!=</span> <span class="n">Complex</span> <span class="ow">and</span> <span class="n">zero_relation_number_set</span> <span class="o">==</span> <span class="n">Complex</span><span class="p">:</span>
            <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">Real</span>
        <span class="k">if</span> <span class="n">major_number_set</span> <span class="o">!=</span> <span class="n">Complex</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">zero_relation_number_set</span> <span class="o">==</span> <span class="n">ComplexNonZero</span><span class="p">):</span>
            <span class="n">zero_relation_number_set</span> <span class="o">=</span> <span class="n">RealNonZero</span>
        <span class="k">return</span> <span class="n">number_set_map</span><span class="p">[(</span><span class="n">major_number_set</span><span class="p">,</span> <span class="n">zero_relation_number_set</span><span class="p">)]</span>

<div class="viewcode-block" id="Mult.deduce_divided_by"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.deduce_divided_by">[docs]</a>    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">deduce_divided_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divisor</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that the product represented by Mult(a,b) is divisible</span>
<span class="sd">        by the divisor a or b. For example,</span>
<span class="sd">           Mult(a, b).deduce_divided_by(a)</span>
<span class="sd">        returns |- Divides(a, Mult(a,b)), that is |- a|ab, (assuming</span>
<span class="sd">        complex a0 and integer b).</span>
<span class="sd">        Later: possibly consider an Equals(divisor,self.lhs) case?</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">divisor</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># a|ab</span>
            <span class="kn">from</span> <span class="nn">proveit.numbers.divisibility</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">left_factor_divisibility</span><span class="p">)</span>
            <span class="n">_x</span><span class="p">,</span> <span class="n">_y</span> <span class="o">=</span> <span class="n">left_factor_divisibility</span><span class="o">.</span><span class="n">instance_params</span>
            <span class="k">return</span> <span class="n">left_factor_divisibility</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">_x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span>
                <span class="n">preserve_expr</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">divisor</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># a|ba</span>
            <span class="kn">from</span> <span class="nn">proveit.numbers.divisibility</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">right_factor_divisibility</span><span class="p">)</span>
            <span class="n">_x</span><span class="p">,</span> <span class="n">_y</span> <span class="o">=</span> <span class="n">right_factor_divisibility</span><span class="o">.</span><span class="n">instance_params</span>
            <span class="k">return</span> <span class="n">right_factor_divisibility</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">_x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span>
                <span class="n">preserve_expr</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;In Mult(</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">).deduce_divided_by(</span><span class="si">{2}</span><span class="s2">), &quot;</span>
                <span class="s2">&quot;the supplied divisor </span><span class="si">{2}</span><span class="s2"> does not appear &quot;</span>
                <span class="s2">&quot;to be equal to either of the multiplicands &quot;</span>
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> or </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span>
                <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">divisor</span><span class="p">))</span></div>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mult_not_eq_zero</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="k">return</span> <span class="n">mult_not_eq_zero</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">},</span>
                                                <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_as_folded</span><span class="p">()</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;shallow_simplified&#39;</span><span class="p">,</span> <span class="s1">&#39;shallow_simplify&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shallow_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">must_evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a proven simplification equation for this Mult</span>
<span class="sd">        expression assuming the operands have been simplified</span>
<span class="sd">        according to the simplification directives as follows:</span>

<span class="sd">        If ungroup is true, dissociate nested multplications.</span>
<span class="sd">        If combine_numeric_rationals is true, multiply numeric rational</span>
<span class="sd">        factors into an evaluated numeric rational constant.</span>
<span class="sd">        If combine_numeric_rational_exponents is true, combine exponents</span>
<span class="sd">        of factors with a common base raised to a numeric rational power</span>
<span class="sd">        (or implicitly a power of 1).</span>
<span class="sd">        If combine_all_exponents is true, exponents with a common base</span>
<span class="sd">        will be combined for any type of exponents (including implicit</span>
<span class="sd">        powers of 1).</span>
<span class="sd">        Sort factors according to order_key_fn where the key is the</span>
<span class="sd">        base that may be raised to a numeric rational power.</span>
<span class="sd">        Eliminate any factors of one, and simplify to zero if there is</span>
<span class="sd">        zero factor.</span>
<span class="sd">        If distribute_numeric_rational is true and there is a single</span>
<span class="sd">        non-constant factor that is an Add expression, distribute any</span>
<span class="sd">        constant factor through the addition.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Exp</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">is_numeric_rational</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mult_zero_left</span><span class="p">,</span> <span class="n">mult_zero_right</span><span class="p">,</span> <span class="n">mult_zero_any</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">empty_mult</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
             <span class="c1"># Multiplication with no operands is equal to 1.</span>
            <span class="k">return</span> <span class="n">empty_mult</span>

        <span class="c1"># First check for any zero factors</span>
        <span class="c1"># -- quickest way to do an evaluation.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">zero_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">zero_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">mult_zero_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">mult_zero_right</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">zero_idx</span><span class="p">]</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">zero_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">mult_zero_any</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">})</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">ProofFailure</span><span class="p">):</span>
            <span class="c1"># No such &quot;luck&quot; regarding a simple multiplication by zero.</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_single</span><span class="p">():</span>
            <span class="c1"># Multiplication with 1 operand is just that operand</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unary_reduction</span><span class="p">(</span><span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># for convenience updating our equation</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Ungroup the expression (disassociate nested multiplications).</span>
        <span class="k">if</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">ungroup</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="c1"># loop through all operands</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="c1"># if it is grouped, ungroup it</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span>
                            <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>

        <span class="c1"># Simplify negations -- factor them out.</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">neg_simplifications</span><span class="p">(</span><span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="c1"># The expression may have changed to a negation after doing</span>
            <span class="c1"># neg_simplification.  Start the simplification of this new</span>
            <span class="c1"># expression fresh at this point.</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">(</span>
                    <span class="n">must_evaluate</span><span class="o">=</span><span class="n">must_evaluate</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># Peform any cancelations between numerators and</span>
        <span class="c1"># denominators of different factors.  This will also</span>
        <span class="c1"># eliminate factors of one.</span>
        <span class="c1"># Since this is supposed to be a shallow simplification,</span>
        <span class="c1"># turn off auto-simplification for these cancelations.</span>
        <span class="k">if</span> <span class="n">Div</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">cancel_factors</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">cancelations</span><span class="p">(</span><span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>  <span class="c1"># done</span>
        
        <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">must_evaluate</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span>
                                 <span class="n">expr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
                <span class="c1"># Try starting over with a call to</span>
                <span class="c1"># shallow_simplification, but only if must_evaluate</span>
                <span class="c1"># is True or the new expression is a Mult not</span>
                <span class="c1"># contained in the original (try to keep the </span>
                <span class="c1"># simplification shallow).</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">(</span>
                        <span class="n">must_evaluate</span><span class="o">=</span><span class="n">must_evaluate</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">elif</span> <span class="n">must_evaluate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands_are_irreducible</span><span class="p">():</span>
            <span class="c1"># Without a zero factor, shallow evaluation of Mult is only</span>
            <span class="c1"># viable if the operands are all irreducible.</span>
            <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_k</span><span class="p">]</span><span class="o">.</span><span class="n">evaluation</span><span class="p">(</span>
                            <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="c1"># Start over now that the terms are all evaluated to</span>
            <span class="c1"># irreducible values.</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">evaluation</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_int</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">):</span>
                    <span class="c1"># Because we do neg_simplifications(), we can</span>
                    <span class="c1"># assume these integers are indeed natural numbers.</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_natural_binary_eval</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Multiply a pair of rational numerals.</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rational_binary_eval</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use pairwise evaluation when multiplying more then 2</span>
                <span class="c1"># operands.</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="k">return</span> <span class="n">pairwise_evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">must_evaluate</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Cabability to evaluate </span><span class="si">%s</span><span class="s2"> is not implemented&quot;</span><span class="o">%</span><span class="n">expr</span><span class="p">)</span>

        <span class="n">order_key_fn</span> <span class="o">=</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">order_key_fn</span>
        <span class="n">combine_all_exponents</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">combine_all_exponents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">combine_all_exponents</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span>
                <span class="o">.</span><span class="n">combine_numeric_rational_exponents</span><span class="p">):</span>
            <span class="c1"># Like factors are ones that are implicit/explicit</span>
            <span class="c1"># exponentials with the same base raised to a literal, </span>
            <span class="c1"># rational power (everything is implicitly raised to the </span>
            <span class="c1"># power of 1).</span>
            <span class="k">def</span> <span class="nf">likeness_key_fn</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">combine_all_exponents</span> <span class="ow">or</span> <span class="n">is_numeric_rational</span><span class="p">(</span>
                                <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">Exp</span><span class="o">.</span><span class="n">_simplification_directives_</span>
                      <span class="o">.</span><span class="n">factor_numeric_rational</span> <span class="ow">and</span>
                      <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">)):</span>
                    <span class="c1"># Don&#39;t combine numeric rationals only to be</span>
                    <span class="c1"># factored again.</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">factor</span>
            <span class="c1"># Combine like operands.</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sorting_and_combining_like_operands</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="n">order_key_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">likeness_key</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
                    <span class="n">likeness_key_fn</span><span class="o">=</span><span class="n">likeness_key_fn</span><span class="p">,</span>
                    <span class="n">preserve_likeness_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="c1"># Simplified to a non-Mult. We&#39;re done.</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">if</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">combine_numeric_rationals</span><span class="p">:</span>
            <span class="c1"># Combines numeric rationals as well as exactly like</span>
            <span class="c1"># factors.</span>
            <span class="k">def</span> <span class="nf">likeness_key_fn</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">one</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">factor</span>
            <span class="c1"># Combine like operands.</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sorting_and_combining_like_operands</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="n">order_key_fn</span><span class="o">=</span><span class="k">lambda</span> <span class="n">likeness_key</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
                    <span class="n">likeness_key_fn</span><span class="o">=</span><span class="n">likeness_key_fn</span><span class="p">,</span>
                    <span class="n">preserve_likeness_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="c1"># Simplified to a non-Mult. We&#39;re done.</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="c1"># See if we should reorder the factors.</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sorting_operands</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">order_key_fn</span><span class="o">=</span><span class="n">order_key_fn</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">distribute_fractions</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> 
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Div</span><span class="p">)</span> <span class="ow">or</span>
                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Div</span><span class="p">))):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">distribution</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">Mult</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">distribute_numeric_rational</span><span class="p">:</span>
            <span class="c1"># If there are exactly two factors and one is an Add and</span>
            <span class="c1"># the other is a numeric literal, distribute over the Add.</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_b</span><span class="p">):</span>
                        <span class="n">_k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">_k</span><span class="p">))</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if Mult._simplification_directives_.irreducibles_in_front:</span>
<span class="sd">            # Move irreducibles to the front.</span>
<span class="sd">            irreducible_factor_index_ranges = []</span>
<span class="sd">            _prev_was_irreducible = False</span>
<span class="sd">            _all_irreducible = True</span>
<span class="sd">            for _k, factor in enumerate(self.factors):</span>
<span class="sd">                if is_irreducible_value(factor):</span>
<span class="sd">                    if _prev_was_irreducible:</span>
<span class="sd">                        # Update a range of irreducible factors.</span>
<span class="sd">                        irreducible_factor_index_ranges[-1][-1] = _k</span>
<span class="sd">                    else:</span>
<span class="sd">                        # Start a new range of irreducibles.</span>
<span class="sd">                        irreducible_factor_index_ranges.append([_k, _k])</span>
<span class="sd">                    _prev_was_irreducible = True</span>
<span class="sd">                else:</span>
<span class="sd">                    _prev_was_irreducible = False</span>
<span class="sd">                    _all_irreducible = False</span>
<span class="sd">            if (len(irreducible_factor_index_ranges) &gt; 0 and</span>
<span class="sd">                    not _all_irreducible):</span>
<span class="sd">                # Move one or more irreducible factors to the front.</span>
<span class="sd">                offset = 0</span>
<span class="sd">                for factor_index_range in reversed(</span>
<span class="sd">                        irreducible_factor_index_ranges):</span>
<span class="sd">                    # Move group of irreducibles to the front.</span>
<span class="sd">                    start, end = factor_index_range</span>
<span class="sd">                    expr = eq.update(expr.group_commutation(</span>
<span class="sd">                            start+offset, 0, end-start+1, </span>
<span class="sd">                            auto_simplify=False))</span>
<span class="sd">                    offset += end - start + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span> <span class="c1"># Should be self=self.</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;unary_reduced&#39;</span><span class="p">,</span> <span class="s1">&#39;unary_reduce&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unary_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reduce a unary multiplication to its operands:</span>
<span class="sd">            Mult(a) = a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">unary_mult_reduction</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_single</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mult.unary_reduction only applicable to a &quot;</span>
                             <span class="s2">&quot;unary Mult, not </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>
         <span class="c1"># Multiplication with 1 operand is just that operand</span>
        <span class="k">return</span> <span class="n">unary_mult_reduction</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">},</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>        

    <span class="k">def</span> <span class="nf">_natural_binary_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the multiplication of two natural numbers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.numerals</span> <span class="k">import</span> <span class="n">DecimalSequence</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">assert</span> <span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_natural</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">)</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">factor</span> <span class="ow">in</span> <span class="n">DIGITS</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">):</span>
            <span class="c1"># multi-digit multiplication</span>
            <span class="k">return</span> <span class="n">DecimalSequence</span><span class="o">.</span><span class="n">mult_eval</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">as_int</span><span class="p">(),</span> <span class="n">_b</span><span class="o">.</span><span class="n">as_int</span><span class="p">())</span>
        <span class="c1"># for single digit addition, import the theorem that provides</span>
        <span class="c1"># the evaluation</span>
        <span class="k">return</span> <span class="n">proveit</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">numerals</span><span class="o">.</span><span class="n">decimals</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span>
                <span class="s1">&#39;mult_</span><span class="si">%d</span><span class="s1">_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">as_int</span><span class="p">(),</span> <span class="n">_b</span><span class="o">.</span><span class="n">as_int</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_rational_binary_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the multiplication of two non-negated</span>
<span class="sd">        rational numbers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Div</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.division</span> <span class="k">import</span> <span class="n">prod_of_fracs</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">assert</span> <span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">)</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rational_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="c1"># The factors should not be negated (that should be dealt</span>
            <span class="c1"># with first via the neg_simplifications method).</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">Div</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span>
                <span class="c1"># n/1 = n:</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">factor</span><span class="o">.</span><span class="n">divide_by_one_elimination</span><span class="p">(</span>
                                <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">rational_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rational_factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rational_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Div</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rational_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Div</span><span class="p">)</span>
        <span class="n">_x</span><span class="p">,</span> <span class="n">_z</span> <span class="o">=</span> <span class="n">rational_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span>
        <span class="n">_y</span><span class="p">,</span> <span class="n">_w</span> <span class="o">=</span> <span class="n">rational_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">return</span> <span class="n">prod_of_fracs</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="n">_y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span><span class="n">_z</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span><span class="n">_w</span><span class="p">},</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">,</span>
                <span class="n">preserve_expr</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        
<div class="viewcode-block" id="Mult.neg_simplifications"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.neg_simplifications">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;simplified_negations&#39;</span><span class="p">,</span> <span class="s1">&#39;simplify_negations&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">neg_simplifications</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equivalence method that derives a simplification in which</span>
<span class="sd">        negated factors are factored out.  For example:</span>
<span class="sd">            (-w)*(-x)*y*(-z) = -(w*x*y*z)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation via</span>
        <span class="c1"># transitivities (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="c1"># Find out the first operand that is a negation for</span>
        <span class="c1"># the purpose of knowing when we should &#39;preserve all&#39;.</span>
        <span class="n">first_neg_operand_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="n">first_neg_operand_idx</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">first_neg_operand_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span> <span class="c1"># trivial self=self</span>

        <span class="c1"># Work in reverse order so indices don&#39;t need to be updated.</span>
        <span class="k">for</span> <span class="n">rev_idx</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="n">rev_idx</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1"># Preserve all until we process the final operand.</span>
                <span class="n">preserve_all</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">first_neg_operand_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">neg_simplification</span><span class="p">(</span>
                            <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="n">preserve_all</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">inner_neg_mult_simplification</span><span class="p">(</span>
                                <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="n">preserve_all</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.neg_simplification"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.neg_simplification">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;simplified_negation&#39;</span><span class="p">,</span> <span class="s1">&#39;simplify_negation&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">neg_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equivalence method that derives a simplification in which</span>
<span class="sd">        a specific negated factor, at the given index, is factored out.</span>
<span class="sd">        For example:</span>
<span class="sd">            w*(-x)*y*z = -(w*x*y*z)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mult_neg_left</span><span class="p">,</span> <span class="n">mult_neg_right</span><span class="p">,</span> <span class="n">mult_neg_any</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Operand at the index </span><span class="si">%d</span><span class="s2"> expected to be a negation for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">mult_neg_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
                <span class="k">return</span> <span class="n">mult_neg_right</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y</span><span class="p">})</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
        <span class="n">_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mult_neg_any</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span></div>

<div class="viewcode-block" id="Mult.one_eliminations"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.one_eliminations">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;eliminated_ones&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminate_ones&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">one_eliminations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equivalence method that derives a simplification in which</span>
<span class="sd">        factors of one are eliminated.  For example:</span>
<span class="sd">            x*1*y*1*z*1 = x*y*z</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation via transitivities.</span>
        <span class="c1"># (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Work in reverse order so indices don&#39;t need to be updated.</span>
        <span class="k">for</span> <span class="n">rev_idx</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">operand</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="n">rev_idx</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">one_elimination</span><span class="p">(</span>
                        <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="c1"># can&#39;t do an elimination if reduced to a single term.</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.one_elimination"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.one_elimination">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;eliminated_one&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminate_one&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">one_elimination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equivalence method that derives a simplification in which</span>
<span class="sd">        a single factor of one, at the given index, is eliminated.</span>
<span class="sd">        For example:</span>
<span class="sd">            x*y*1*z = x*y*z</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">elim_one_left</span><span class="p">,</span> <span class="n">elim_one_right</span><span class="p">,</span> <span class="n">elim_one_any</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Operand at the index </span><span class="si">%d</span><span class="s2"> expected to be 1 for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">elim_one_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">elim_one_right</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">elim_one_any</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">})</span></div>

<div class="viewcode-block" id="Mult.deep_one_eliminations"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.deep_one_eliminations">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;deep_eliminated_ones&#39;</span><span class="p">,</span> <span class="s1">&#39;deep_eliminate_ones&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">deep_one_eliminations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Eliminate ones from direct factors as well as grouped</span>
<span class="sd">        factors and in fraction factors.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation</span>
        <span class="c1"># via transitivities (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="s1">&#39;deep_one_eliminations&#39;</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span>
                                 <span class="n">deep_one_eliminations</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">one_eliminations</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.cancelations"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.cancelations">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;all_canceled&#39;</span><span class="p">,</span> <span class="s1">&#39;all_cancel&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cancelations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce and return an equality between self and a form in which</span>
<span class="sd">        all simple division cancelations are performed across the</span>
<span class="sd">        factors of this multiplication.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Div</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation via</span>
        <span class="c1"># transitivities (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Eliminate any ones &quot;deeply&quot;.  Ones can be eliminated without</span>
        <span class="c1"># any cancelation.</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deep_one_eliminations</span><span class="p">())</span>

        <span class="n">numer_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="n">numer_factors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numer_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                        <span class="n">denom_factors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">denom_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">numer_factors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">denom_factors_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">denom_factors</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">numer_factor</span> <span class="ow">in</span> <span class="n">numer_factors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numer_factor</span> <span class="ow">in</span> <span class="n">denom_factors_set</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span><span class="n">numer_factor</span><span class="p">,</span>
                                                  <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">denom_factors_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">numer_factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.cancelation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.cancelation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;canceled&#39;</span><span class="p">,</span> <span class="s1">&#39;cancel&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cancelation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_to_cancel</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce and return an equality between self and a form in which</span>
<span class="sd">        the given factor has been canceled in a numerator (or factor)</span>
<span class="sd">        and denominator.  For example,</span>
<span class="sd">        [a*b*c*(1/b)].cancelation(b) would return</span>
<span class="sd">        a*b*c*(1/b) = a*c</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Div</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">one</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">term_to_cancel</span> <span class="ow">in</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;term_to_cancel&#39; must not be zero or one&quot;</span><span class="p">)</span>

        <span class="n">numer_occurrence_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_occurrence_indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                <span class="n">numer_factors</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="o">.</span><span class="n">factors</span> <span class="k">if</span>
                                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span>
                                 <span class="k">else</span> <span class="p">[</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">])</span>
                <span class="n">denom_factors</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="o">.</span><span class="n">factors</span> <span class="k">if</span>
                                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span>
                                 <span class="k">else</span> <span class="p">[</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer_factors</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">factors</span> <span class="k">if</span>
                                 <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">factor</span><span class="p">])</span>
                <span class="n">denom_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">term_to_cancel</span> <span class="ow">in</span> <span class="n">numer_factors</span><span class="p">:</span>
                <span class="n">numer_occurrence_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">term_to_cancel</span> <span class="ow">in</span> <span class="n">denom_factors</span><span class="p">:</span>
                <span class="n">denom_occurrence_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numer_occurrence_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">denom_occurrence_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No occurrences of </span><span class="si">%s</span><span class="s2"> to cancel were found &quot;</span>
                             <span class="s2">&quot;in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">term_to_cancel</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

        <span class="c1"># If there is an occurrence of the numerator and denominator</span>
        <span class="c1"># within the same Div factor, that&#39;s ideal.</span>
        <span class="n">intersection_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">numer_occurrence_indices</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">denom_occurrence_indices</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intersection_indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span>
                <span class="n">term_to_cancel</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># Handle the special case of two neighboring factors which</span>
        <span class="c1"># serves as the base case.</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">proveit.numbers.division</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">mult_frac_cancel_numer_left</span><span class="p">,</span> <span class="n">mult_frac_cancel_denom_left</span><span class="p">)</span>

            <span class="c1"># First, let&#39;s eliminate any ones from the canceling</span>
            <span class="c1"># parts (and division by one).  We&#39;ll also do this</span>
            <span class="c1"># for the instantiated theorem to ensure there is a match.</span>
            <span class="n">numer_idx</span> <span class="o">=</span> <span class="n">numer_occurrence_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">denom_idx</span> <span class="o">=</span> <span class="n">denom_occurrence_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">updated_canceling_numer_inner_expr</span><span class="p">():</span>
                <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">numer_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inner_expr</span><span class="o">.</span><span class="n">cur_sub_expr</span><span class="p">(),</span> <span class="n">Div</span><span class="p">):</span>
                    <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">inner_expr</span><span class="o">.</span><span class="n">numerator</span>
                <span class="k">return</span> <span class="n">inner_expr</span><span class="p">,</span> <span class="n">inner_expr</span><span class="o">.</span><span class="n">cur_sub_expr</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">updated_canceling_denom_inner_expr</span><span class="p">():</span>
                <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">denom_idx</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inner_expr</span><span class="o">.</span><span class="n">cur_sub_expr</span><span class="p">(),</span> <span class="n">Div</span><span class="p">)</span>
                <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">inner_expr</span><span class="o">.</span><span class="n">denominator</span>
                <span class="k">return</span> <span class="n">inner_expr</span><span class="p">,</span> <span class="n">inner_expr</span><span class="o">.</span><span class="n">cur_sub_expr</span><span class="p">()</span>
            <span class="n">canceling_numer_inner_expr</span><span class="p">,</span> <span class="n">canceling_numer_expr</span> <span class="o">=</span> \
                <span class="n">updated_canceling_numer_inner_expr</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_numer_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">one_elims</span> <span class="o">=</span> <span class="n">canceling_numer_inner_expr</span><span class="o">.</span><span class="n">deep_one_eliminations</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">one_elims</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">one_elims</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
                    <span class="c1"># Update canceling numerator with one eliminations.</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">one_elims</span><span class="p">)</span>
                    <span class="n">canceling_numer_inner_expr</span><span class="p">,</span> <span class="n">canceling_numer_expr</span> <span class="o">=</span> \
                        <span class="n">updated_canceling_numer_inner_expr</span><span class="p">()</span>
            <span class="n">canceling_denom_inner_expr</span><span class="p">,</span> <span class="n">canceling_denom_expr</span> <span class="o">=</span> \
                <span class="n">updated_canceling_denom_inner_expr</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_denom_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">one_elims</span> <span class="o">=</span> <span class="n">canceling_denom_inner_expr</span><span class="o">.</span><span class="n">deep_one_eliminations</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">one_elims</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">one_elims</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
                    <span class="c1"># Update canceling denominator with one elims.</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">one_elims</span><span class="p">)</span>
                    <span class="n">canceling_denom_inner_expr</span><span class="p">,</span> <span class="n">canceling_denom_expr</span> <span class="o">=</span> \
                        <span class="n">updated_canceling_denom_inner_expr</span><span class="p">()</span>

            <span class="c1"># Factor the canceling numerator and denominator as</span>
            <span class="c1"># appropriate.</span>
            <span class="k">if</span> <span class="n">canceling_numer_expr</span> <span class="o">!=</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_numer_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span>
                <span class="n">pull</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="n">numer_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">canceling_numer_inner_expr</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                    <span class="n">term_to_cancel</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">canceling_numer_inner_expr</span><span class="p">,</span> <span class="n">canceling_numer_expr</span> <span class="o">=</span> \
                    <span class="n">updated_canceling_numer_inner_expr</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">canceling_denom_expr</span> <span class="o">!=</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_denom_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span>
                <span class="n">pull</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="n">denom_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">canceling_denom_inner_expr</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                    <span class="n">term_to_cancel</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">canceling_numer_inner_expr</span><span class="p">,</span> <span class="n">canceling_numer_expr</span> <span class="o">=</span> \
                    <span class="n">updated_canceling_numer_inner_expr</span><span class="p">()</span>

            <span class="n">left_factor</span><span class="p">,</span> <span class="n">right_factor</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span>

            <span class="k">if</span> <span class="n">numer_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># numerator on the left side:</span>
                <span class="k">assert</span> <span class="n">denom_idx</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">denom_idx</span><span class="p">],</span> <span class="n">Div</span><span class="p">)</span>
                <span class="c1"># [(a*b)/c]*[(d/(b*e))] = (a/c)*(d/e)</span>
                <span class="n">_b</span> <span class="o">=</span> <span class="n">term_to_cancel</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                    <span class="n">_c</span> <span class="o">=</span> <span class="n">left_factor</span><span class="o">.</span><span class="n">denominator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_c</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">if</span> <span class="n">canceling_numer_expr</span> <span class="o">==</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                    <span class="n">_a</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_numer_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">canceling_numer_expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">())</span>
                    <span class="n">_a</span> <span class="o">=</span> <span class="n">canceling_numer_expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="n">right_factor</span><span class="o">.</span><span class="n">numerator</span>
                <span class="k">if</span> <span class="n">canceling_denom_expr</span> <span class="o">==</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                    <span class="n">_e</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_denom_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">canceling_denom_expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">())</span>
                    <span class="n">_e</span> <span class="o">=</span> <span class="n">canceling_denom_expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cancelation</span> <span class="o">=</span> <span class="n">mult_frac_cancel_numer_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_d</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">_e</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># numerator on the right side</span>
                <span class="k">assert</span> <span class="n">numer_idx</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">denom_idx</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">denom_idx</span><span class="p">],</span> <span class="n">Div</span><span class="p">)</span>
                <span class="c1"># [a/(b*c)]*[((c*e)/d)] = (a/b)*(d/e)</span>
                <span class="n">_c</span> <span class="o">=</span> <span class="n">term_to_cancel</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                    <span class="n">_a</span> <span class="o">=</span> <span class="n">left_factor</span><span class="o">.</span><span class="n">numerator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_a</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">if</span> <span class="n">canceling_denom_expr</span> <span class="o">==</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                    <span class="n">_b</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_denom_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">canceling_denom_expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">())</span>
                    <span class="n">_b</span> <span class="o">=</span> <span class="n">canceling_denom_expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">canceling_numer_expr</span> <span class="o">==</span> <span class="n">term_to_cancel</span><span class="p">:</span>
                    <span class="n">_d</span> <span class="o">=</span> <span class="n">one</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">canceling_numer_expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">canceling_numer_expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">())</span>
                    <span class="n">_d</span> <span class="o">=</span> <span class="n">canceling_numer_expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                    <span class="n">_e</span> <span class="o">=</span> <span class="n">right_factor</span><span class="o">.</span><span class="n">denominator</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_e</span> <span class="o">=</span> <span class="n">one</span>
                <span class="n">cancelation</span> <span class="o">=</span> <span class="n">mult_frac_cancel_denom_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_d</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">_e</span><span class="p">})</span>
            <span class="c1"># Eliminate ones in the cancelation; it should now</span>
            <span class="c1"># match with the expression where we have already</span>
            <span class="c1"># eliminated ones.</span>
            <span class="n">cancelation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cancelation</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">deep_eliminate_ones</span><span class="p">())</span>
            <span class="n">cancelation</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">cancelation</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">deep_eliminate_ones</span><span class="p">())</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cancelation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># If there are neighboring occurrences, that is the next</span>
        <span class="c1"># best thing.</span>
        <span class="n">denom_occurrence_indices_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">denom_occurrence_indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">numer_idx</span> <span class="ow">in</span> <span class="n">numer_occurrence_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numer_idx</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">denom_occurrence_indices_set</span><span class="p">:</span>
                <span class="n">left_idx</span> <span class="o">=</span> <span class="n">numer_idx</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">numer_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">denom_occurrence_indices_set</span><span class="p">:</span>
                <span class="n">left_idx</span> <span class="o">=</span> <span class="n">numer_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Found neighboring occurrences.  Group, cancel,</span>
            <span class="c1"># then ungroup (if necessary).</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                <span class="n">left_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">left_idx</span><span class="p">]</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span>
                    <span class="n">term_to_cancel</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">left_idx</span><span class="p">],</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="n">left_idx</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># As the last resort, we simply move the first occurrences</span>
        <span class="c1"># next to each other, cancel, then move them back if needed.</span>
        <span class="c1"># (This specific approach is a little funny since it will end up</span>
        <span class="c1"># swapping sides when they move next to each other, but it</span>
        <span class="c1"># should work fine and makes the code more straightforward.)</span>
        <span class="n">numer_idx</span> <span class="o">=</span> <span class="n">numer_occurrence_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">denom_idx</span> <span class="o">=</span> <span class="n">denom_occurrence_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span><span class="n">denom_idx</span><span class="p">,</span> <span class="n">numer_idx</span><span class="p">))</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span><span class="n">term_to_cancel</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">():</span>
            <span class="c1"># It must have been a complete cancelation, so no</span>
            <span class="c1"># reason to move anything back.</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># If not already finished and returned, we should put things</span>
        <span class="c1"># back where they were to play nice.</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span><span class="n">numer_idx</span><span class="p">,</span> <span class="n">denom_idx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.conversion_to_addition"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.conversion_to_addition">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;converted_to_addition&#39;</span><span class="p">,</span> <span class="s1">&#39;convert_to_addition&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">conversion_to_addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From multiplication by an integer as the first factor,</span>
<span class="sd">        derive and return the equivalence of this multiplication</span>
<span class="sd">        to a repeated addition; for example, 3*c = c + c + c.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mult_def</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;as_int&#39;</span><span class="p">):</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot &#39;expand_as_addition&#39; unless the first operand &quot;</span>
                <span class="s2">&quot;is a literal integer: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># for convenience updating our equation</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Group together the remaining factors if necessary:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">preserve_expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mult_def</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">},</span>
                                        <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Mult.index"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_factor</span><span class="p">,</span> <span class="n">also_return_num</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the starting index of the_factor, which may be a single</span>
<span class="sd">        operand, a list of consecutive operands, or a Mult expression</span>
<span class="sd">        that represents the product of the list of consecutive operands.</span>
<span class="sd">        If also_return_num is True, return a tuple of the index and</span>
<span class="sd">        number of operands for the_factor.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factor</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="n">the_factor</span> <span class="o">=</span> <span class="n">the_factor</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">the_factor</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">the_factor</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
            <span class="c1"># multiple operands in the_factor</span>
            <span class="n">first_factor</span> <span class="o">=</span> <span class="n">the_factor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_factor</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">first_factor</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">entries</span> <span class="o">==</span> <span class="p">(</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="n">the_factor</span><span class="p">)):</span>
                        <span class="k">break</span>  <span class="c1"># found it all!</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Factor is absent!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">the_factor</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Factor is absent!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">also_return_num</span> <span class="k">else</span> <span class="n">idx</span></div>

<div class="viewcode-block" id="Mult.distribution"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.distribution">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;distributed&#39;</span><span class="p">,</span> <span class="s1">&#39;distribute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> 
                     <span class="n">left_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Distribute through the operand at the given index.</span>
<span class="sd">        Returns the equality that equates self to this new version.</span>
<span class="sd">        Examples:</span>
<span class="sd">            a (b + c + a) d = a b d + a c d + a a d</span>
<span class="sd">            a (b - c) d = a b d - a c d</span>
<span class="sd">            a (\sum_x f(x)) c = \sum_x a f(x) c</span>
<span class="sd">            (a/b)*(c/d) = (a*b)/(c*d)</span>
<span class="sd">        Example for a distribute_all_sums:</span>
<span class="sd">            recursively looks for first add or sum to distribute through</span>
<span class="sd">            (a+b)(c+d)ef = a(c+d)ef + b(c+d)ef</span>
<span class="sd">                         = acef + adef + bcef + bdef</span>
<span class="sd">        </span>
<span class="sd">        For more flexibility, &#39;left_factors&#39; and &#39;right_factors&#39;</span>
<span class="sd">        may be specified to indicate subsets of the factors to</span>
<span class="sd">        distribute on the left vs right. The &#39;left_factors&#39; and </span>
<span class="sd">        &#39;right_factors&#39; may be provided as indices instead.</span>
<span class="sd">        Examples:</span>
<span class="sd">            a b (c + d) e f = a (b c f + b d f) e</span>
<span class="sd">        with left_factors: [b], right_factors: [f]</span>
<span class="sd">        or left_factors: [1], right_factors: [4]</span>
<span class="sd">            a b (c + d) e f = a (f c b e + f d b e)</span>
<span class="sd">        with left_factors: [f], right_factors: [b, e]</span>
<span class="sd">        or left_factors: [4], right_factors: [1, 3]</span>
<span class="sd">        If one of these is specified but not the other, the emtpy set</span>
<span class="sd">        is used for the one that isn&#39;t specified.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span><span class="n">distribute_through_sum</span><span class="p">,</span> <span class="n">distribute_through_subtract</span><span class="p">,</span>
                       <span class="n">distribute_through_abs_sum</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.division</span> <span class="k">import</span> <span class="n">prod_of_fracs</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">Sum</span>
        <span class="k">if</span> <span class="n">left_factors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">right_factors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Specific factors to be applied to the left and/or right</span>
            <span class="c1"># were provided.  So we&#39;ll reorder the factors and then</span>
            <span class="c1"># associate appropriately before distributing.</span>
            <span class="k">if</span> <span class="n">left_factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">left_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">right_factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">right_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Convert from expressions to indices for the left and</span>
            <span class="c1"># right factors (exclude the &#39;idx&#39;).</span>
            <span class="n">factor_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">factor</span><span class="p">:</span><span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">factor</span> 
                               <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="k">if</span> <span class="n">_k</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">}</span>
            <span class="n">left_factor_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left_factors</span><span class="p">)</span>
            <span class="n">right_factor_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">right_factors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">factor_indices</span> <span class="ow">in</span> <span class="p">(</span><span class="n">left_factor_indices</span><span class="p">,</span> <span class="n">right_factor_indices</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factor_indices</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                            <span class="n">factor_indices</span><span class="p">[</span><span class="n">_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor_to_index</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;The &#39;left_factors&#39;, </span><span class="si">%s</span><span class="s2">, and &#39;right_factors&#39;&quot;</span>
                                <span class="s2">&quot;, </span><span class="si">%s</span><span class="s2">, do not all appear in </span><span class="si">%s</span><span class="s2">&quot;</span>
                                <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_factors</span><span class="p">,</span> <span class="n">right_factors</span><span class="p">))</span>
            <span class="c1"># Permute the factors so the left factors come just before</span>
            <span class="c1"># the factor to distribute through and the right factors </span>
            <span class="c1"># come just after.</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span>
            <span class="n">num_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>
            <span class="n">special_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">left_factor_indices</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="n">right_factor_indices</span><span class="p">)</span>
            <span class="n">before_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">_idx</span> <span class="k">for</span> <span class="n">_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span>
                              <span class="n">_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">special_indices</span><span class="p">]</span>
            <span class="n">after_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">_idx</span> <span class="k">for</span> <span class="n">_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_factors</span><span class="p">)</span> <span class="k">if</span>
                              <span class="n">_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">special_indices</span><span class="p">]</span>
            <span class="n">new_order</span> <span class="o">=</span> <span class="p">(</span><span class="n">before_indices</span> <span class="o">+</span> <span class="n">left_factor_indices</span> <span class="o">+</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span>
                         <span class="n">right_factor_indices</span> <span class="o">+</span> <span class="n">after_indices</span><span class="p">)</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">new_order</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="c1"># Convert from indices to expressions.</span>
            <span class="n">left_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">left_factor_indices</span><span class="p">]</span>
            <span class="n">right_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">right_factor_indices</span><span class="p">]</span>
            <span class="c1"># Make the distribution.</span>
            <span class="n">num_left_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_factors</span><span class="p">)</span>
            <span class="n">distribution</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">left_factors</span><span class="p">,</span> <span class="n">factors</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> 
                                <span class="o">*</span><span class="n">right_factors</span><span class="p">)</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span>
                                        <span class="n">num_left_factors</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">before_indices</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">after_indices</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1"># No factors are left out of the distribution.</span>
                <span class="c1"># For example: a b (c + d) e f = a f c b e + a f d b e</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">distribution</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
            <span class="c1"># Now associate to include from left factors to right</span>
            <span class="c1"># factors and simultaneously replace with the distribution.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">before_indices</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">num_left_factors</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_factors</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                    <span class="n">start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="p">[</span><span class="n">distribution</span><span class="p">],</span>
                    <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">prod_of_fracs</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span>
                     <span class="n">y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span>
                     <span class="n">z</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span>
                     <span class="n">w</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">denominator</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Div</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">proveit.numbers.division</span> <span class="k">import</span> <span class="n">mult_frac_left</span>
                <span class="k">return</span> <span class="n">mult_frac_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span>
                     <span class="n">y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">z</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">denominator</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Div</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">proveit.numbers.division</span> <span class="k">import</span> <span class="n">mult_frac_right</span>
                <span class="k">return</span> <span class="n">mult_frac_right</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span>
                     <span class="n">z</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">denominator</span><span class="p">})</span>

        <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_k</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">and</span> <span class="n">operand</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span>
              <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">)):</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_k</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">return</span> <span class="n">distribute_through_subtract</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">distribute_through_sum</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_k</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Abs</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="c1"># For example,</span>
            <span class="c1"># x * |a + b + c| * y * z = |x*a*y*z + x*b*y*z + x*c*y*z|</span>
            <span class="c1"># if x, y, and z are non-negative.</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">equiv</span> <span class="o">=</span> <span class="n">distribute_through_abs_sum</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_k</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">equiv</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Mult.distribution must be updated &quot;</span>
                                      <span class="s2">&quot;for Div case.&quot;</span><span class="p">)</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            eqn = frac_in_prod.instantiate(</span>
<span class="sd">                    {w_multi:self.operands[:idx],</span>
<span class="sd">                     x:self.operands[idx].operands[0],</span>
<span class="sd">                     y:self.operands[idx].operands[1],</span>
<span class="sd">                     z_multi:self.operands[idx+1:]}, assumptions=assumptions)</span>
<span class="sd">            try:</span>
<span class="sd">                # see if the numerator can simplify (e.g., with a one factor)</span>
<span class="sd">                numer_simplification = eqn.rhs.numerator.simplification(</span>
<span class="sd">                        assumptions=assumptions)</span>
<span class="sd">                dummy_var = eqn.safe_dummy_var()</span>
<span class="sd">                return numer_simplification.sub_right_side_into(</span>
<span class="sd">                        Equals(eqn.lhs, frac(dummy_var, eqn.rhs.denominator)),</span>
<span class="sd">                               dummy_var)</span>
<span class="sd">            except:</span>
<span class="sd">                return eqn</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Sum</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Mult.distribution must be updated &quot;</span>
                                      <span class="s2">&quot;for Sum case.&quot;</span><span class="p">)</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            y_multi_sub = operand.indices</span>
<span class="sd">            Pop, Pop_sub = Function(P, operand.indices), operand.summand</span>
<span class="sd">            S_sub = operand.domain</span>
<span class="sd">            x_dummy, z_dummy = self.safe_dummy_vars(2)</span>
<span class="sd">            spec1 = distribute_through_summation.instantiate(</span>
<span class="sd">                    {Pop:Pop_sub, S:S_sub, y_multi:y_multi_sub,</span>
<span class="sd">                     x_multi:Etcetera(Multi_variable(x_dummy)),</span>
<span class="sd">                     z_multi:Etcetera(Multi_variable(z_dummy))},</span>
<span class="sd">                     assumptions=assumptions)</span>
<span class="sd">            return spec1.derive_conclusion().instantiate(</span>
<span class="sd">                    {Etcetera(Multi_variable(x_dummy)):self.operands[:idx],</span>
<span class="sd">                     Etcetera(Multi_variable(z_dummy)):self.operands[idx+1:]},</span>
<span class="sd">                     assumptions=assumptions)</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Unsupported operand type to distribute over: &quot;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">readily_factorable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True iff &#39;factor&#39; is factorable from &#39;self&#39; in an</span>
<span class="sd">        obvious manner.  For this Mult, it is readily factorable if</span>
<span class="sd">        it is readily factorable from any factor of the Mult.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">one</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Exp</span><span class="p">,</span> <span class="n">readily_factorable</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">factor</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># First check to see if there is a direct factor.</span>
        <span class="k">for</span> <span class="n">_factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="n">_factor</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # Check to see if factors are distributed throughout.</span>
<span class="sd">        candidate_factors = (factor,)</span>
<span class="sd">        if isinstance(factor, Mult):</span>
<span class="sd">            candidate_factors = factor</span>
<span class="sd">        elif isinstance(factor, Div):</span>
<span class="sd">            candidate_factors = (factor.numerator, </span>
<span class="sd">                                 Exp(factor.denominator, Neg(one)))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Return true if all factors of &#39;factor&#39; are common factors</span>
        <span class="c1"># of self.</span>
        <span class="k">return</span> <span class="n">remove_common_factors</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">==</span><span class="n">one</span>

<div class="viewcode-block" id="Mult.factorization"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.factorization">[docs]</a>    <span class="nd">@auto_equality_prover</span><span class="p">(</span><span class="s1">&#39;factorized&#39;</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_factors_or_index</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                      <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">group_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the proven factorization (equality with the factored</span>
<span class="sd">        form) from pulling the factor(s) from this product to the </span>
<span class="sd">        &quot;left&quot; or &quot;right&quot;.  the_factors_or_index may be an iterable or </span>
<span class="sd">        a Mult; in either case, the individual factors will be pulled</span>
<span class="sd">        together in the pull direction.</span>
<span class="sd">        If there are multiple occurrences, the first</span>
<span class="sd">        occurrence is used.  If group_factors is True, the factors are </span>
<span class="sd">        grouped together as a sub-product.</span>
<span class="sd">        If group_remainder is True and there are multiple remaining</span>
<span class="sd">        operands, then these remaining</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Div</span><span class="p">,</span> <span class="n">readily_factorable</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_factors_or_index</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>  <span class="c1"># self = self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="n">the_factors_or_index</span><span class="o">.</span><span class="n">reduction_to_mult</span><span class="p">(</span>
                <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">reduction</span><span class="o">.</span><span class="n">rhs</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reduction</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                    <span class="n">factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="n">group_factors</span><span class="p">,</span>
                    <span class="n">group_remainder</span><span class="o">=</span><span class="n">group_remainder</span><span class="p">,</span>
                    <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Let&#39;s just see if the entire expression is a factor.</span>
                <span class="n">the_factors_or_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                        <span class="n">the_factors_or_index</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="n">the_factors_or_index</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">the_factors_or_index</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">):</span>
                    <span class="n">the_factors_or_index</span> <span class="o">=</span> <span class="n">the_factors_or_index</span><span class="o">.</span><span class="n">entries</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">the_factors_or_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">the_factors_or_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">the_factors_or_index</span>
            <span class="n">num_factored</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">the_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span>
                    <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="n">num_factored</span><span class="p">))</span>
            <span class="n">all_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">the_factor</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Look for one or more factors, pull them out,</span>
            <span class="c1"># grouping where possible.</span>
            <span class="n">the_factors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">the_factors_or_index</span><span class="p">)</span>
            <span class="n">the_factors_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">all_factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">my_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span>
            <span class="n">num_factored</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
                        
            <span class="k">def</span> <span class="nf">move_slice</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">the_slice</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">num_factored</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">the_slice</span><span class="o">.</span><span class="n">start</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">idx</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">shift</span>
                <span class="n">_num_factors</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">pull</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">==</span><span class="n">num_factored</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">pull</span><span class="o">==</span><span class="s1">&#39;right&#39;</span> <span class="ow">and</span> 
                         <span class="n">idx</span><span class="o">==</span><span class="n">_num_factors</span><span class="o">-</span><span class="n">length</span><span class="p">)):</span>
                    <span class="c1"># Preserve-all until the last step.</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">group_commutation</span><span class="p">(</span>
                        <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">num_factored</span> <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> 
                              <span class="k">else</span> <span class="o">-</span><span class="n">length</span><span class="p">),</span> 
                        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;disassociate&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                        <span class="n">length</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="n">length</span>
            
            <span class="k">while</span> <span class="n">the_factors_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_factors</span><span class="p">):</span>
                <span class="c1"># Find the next factor.</span>
                <span class="n">next_factor</span> <span class="o">=</span> <span class="n">the_factors</span><span class="p">[</span><span class="n">the_factors_idx</span><span class="p">]</span>
                <span class="n">all_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_factor</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">next_idx</span> <span class="o">=</span> <span class="n">my_factors</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">next_factor</span><span class="p">)</span>
                    <span class="n">nested_factor</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">next_idx</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_factors</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">next_factor</span><span class="p">):</span>
                            <span class="c1"># Factor &#39;next_factor&#39; out of one of</span>
                            <span class="c1"># the factors of &#39;self&#39;.</span>
                            <span class="n">nested_factor</span> <span class="o">=</span> <span class="n">next_factor</span>
                            <span class="n">next_idx</span> <span class="o">=</span> <span class="n">idx</span>
                    <span class="k">if</span> <span class="n">next_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> not found as a factor of </span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span><span class="p">(</span><span class="n">next_factor</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
                <span class="n">the_factors_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="c1"># Join with any other factors that appear consecutively.</span>
                <span class="n">num_expr_factors</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                <span class="n">the_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">next_idx</span><span class="p">,</span> <span class="n">next_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;right&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nested_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="k">while</span> <span class="n">the_factors_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_factors</span><span class="p">):</span>
                        <span class="n">_factor</span> <span class="o">=</span> <span class="n">the_factors</span><span class="p">[</span><span class="n">the_factors_idx</span><span class="p">]</span>
                        <span class="n">stop</span> <span class="o">=</span> <span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span>
                        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_factors</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">my_factors</span><span class="p">[</span><span class="n">stop</span><span class="p">]</span><span class="o">==</span><span class="n">_factor</span><span class="p">:</span>
                            <span class="n">the_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">the_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                              <span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">all_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_factor</span><span class="p">)</span>
                            <span class="n">the_factors_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pull</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="ow">and</span> <span class="n">readily_factorable</span><span class="p">(</span>
                                <span class="n">my_factors</span><span class="p">[</span><span class="n">stop</span><span class="p">],</span> <span class="n">_factor</span><span class="p">)):</span>
                            <span class="n">nested_factor</span> <span class="o">=</span> <span class="n">_factor</span>
                            <span class="n">the_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">the_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                              <span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">all_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_factor</span><span class="p">)</span>
                            <span class="n">the_factors_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">break</span>
                        <span class="k">break</span> <span class="c1"># end of consecutive factors</span>
                
                <span class="k">if</span> <span class="n">nested_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">prev_num_expr_factors</span> <span class="o">=</span> <span class="n">num_expr_factors</span>
                    <span class="n">_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">shift</span><span class="o">+</span><span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="k">else</span>
                            <span class="n">shift</span><span class="o">+</span><span class="n">the_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="o">==</span> 
                            <span class="n">nested_factor</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()):</span>
                        <span class="c1"># Not really a nested factor -- just</span>
                        <span class="c1"># a different expression with the same</span>
                        <span class="c1"># canonical form.</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span>
                                <span class="o">.</span><span class="n">deduce_canonically_equal</span><span class="p">(</span>
                                        <span class="n">nested_factor</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span>
                                <span class="o">.</span><span class="n">factorization</span><span class="p">(</span><span class="n">nested_factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span>
                                               <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">group_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="n">_idx</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;right&#39;</span><span class="p">:</span>
                            <span class="c1"># Shift the slice to account for the</span>
                            <span class="c1"># factorization.</span>
                            <span class="n">extra_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span>
                                           <span class="n">prev_num_expr_factors</span><span class="p">)</span>
                            <span class="n">the_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">the_slice</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="n">extra_shift</span><span class="p">,</span>
                                              <span class="n">the_slice</span><span class="o">.</span><span class="n">stop</span><span class="o">+</span><span class="n">extra_shift</span><span class="p">)</span>

                <span class="c1"># Go ahead and move &#39;the_slice&#39;</span>
                <span class="k">if</span> <span class="n">the_factors_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_factors</span><span class="p">):</span>
                    <span class="c1"># Move this slice with more factors to find.</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">move_slice</span><span class="p">(</span>
                            <span class="n">expr</span><span class="p">,</span> <span class="n">the_slice</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">num_factored</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Last one to move. Possibly simplify and/or keep</span>
                    <span class="c1"># associated.</span>
                    <span class="n">disassociate</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_factored</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">group_factors</span><span class="p">)</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">move_slice</span><span class="p">(</span>
                            <span class="n">expr</span><span class="p">,</span> <span class="n">the_slice</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">num_factored</span><span class="p">,</span> 
                            <span class="n">disassociate</span><span class="o">=</span><span class="n">disassociate</span><span class="p">)</span>
                    
                <span class="n">num_factored</span> <span class="o">+=</span> <span class="n">length</span>
                <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">+=</span> <span class="n">length</span>
                    <span class="n">my_factors</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="n">num_factored</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">my_factors</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">[:</span><span class="o">-</span><span class="n">num_factored</span><span class="p">]</span>
                    
        <span class="n">group_factors</span> <span class="o">=</span> <span class="n">group_factors</span> <span class="ow">and</span> <span class="n">num_factored</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">group_remainder</span> <span class="o">=</span> <span class="n">group_remainder</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="n">num_factored</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Group the factors if needed.</span>
        <span class="k">if</span> <span class="n">group_factors</span><span class="p">:</span>
            <span class="c1"># use 0:num_factored type of convention like standard python</span>
            <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">num_factored</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                        <span class="o">-</span><span class="n">num_factored</span><span class="p">,</span> <span class="n">num_factored</span><span class="p">))</span>
        <span class="n">num_factor_operands</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">group_factors</span> <span class="k">else</span> <span class="n">num_factored</span>
        <span class="k">if</span> <span class="n">group_remainder</span><span class="p">:</span>
            <span class="c1"># if the factor has been group, effectively there is just 1</span>
            <span class="c1"># factor operand now</span>
            <span class="n">num_remainder_operands</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span>
                                      <span class="n">num_factor_operands</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                        <span class="n">num_factor_operands</span><span class="p">,</span> <span class="n">num_remainder_operands</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">num_remainder_operands</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

    <span class="nd">@auto_equality_prover</span><span class="p">(</span><span class="s1">&#39;combined_exponents&#39;</span><span class="p">,</span> <span class="s1">&#39;combine_exponents&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">combining_exponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive and return this Mult expression equated to the</span>
<span class="sd">        expression in which some or all of the exponential factors</span>
<span class="sd">        with common bases have been combined, or all or some of the</span>
<span class="sd">        exponential factors with common exponents have been combined.</span>
<span class="sd">        For example:</span>
<span class="sd">        |- a^b a^c    = a^{b+c},</span>
<span class="sd">        |- a^b a^{-c} = a^{b-c},</span>
<span class="sd">        |- a^b a      = a^{b+1},</span>
<span class="sd">        |- a a^b      = a^{1+b},</span>
<span class="sd">        This also should work more generally with more than 2 factors,</span>
<span class="sd">        for example taking a^b a^c a^d to</span>
<span class="sd">        |- (a^b a^c a^d) = a^{b+c+d}.</span>
<span class="sd">        The start_idx and end_idx can be used to apply the process to</span>
<span class="sd">        a contiguous subset of factors within a larger set of factors.</span>
<span class="sd">        Planned but not implemented: allow user to specify non-</span>
<span class="sd">        contiguous factors to combine. For example, given self as</span>
<span class="sd">        a^b a^c b^a a^d</span>
<span class="sd">        allow user to specify indices 0, 1, 3 to produce something like</span>
<span class="sd">        |- a^{b+c+d} b^a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.number_operation</span> <span class="k">import</span> <span class="n">union_number_set</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">as</span> <span class="nn">exp_pkg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Exp</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">empty_mult</span>

        <span class="c1"># If the start_idx and/or end_idx has been specified</span>
        <span class="k">if</span> <span class="n">start_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Compensate for potential missing indices in this block:</span>
            <span class="c1"># omission of either start or end idx defaults to a pair</span>
            <span class="c1"># of contiguous multiplicands</span>
            <span class="k">if</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">start_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">assoc_length</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># associate the factors intended for combination</span>
            <span class="c1"># warning: 2nd arg of association() fxn is length not index</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">association</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">assoc_length</span><span class="p">)</span>
            <span class="c1"># isolate the targeted factors and combine them as desired</span>
            <span class="c1"># using call to this same method</span>
            <span class="n">inner_combination</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">grouped</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span><span class="o">.</span>
                    <span class="n">combining_exponents</span><span class="p">())</span>
            <span class="c1"># substitute the combined factors back into the</span>
            <span class="c1"># grouped expression and return the deduced equality</span>
            <span class="k">return</span> <span class="n">inner_combination</span><span class="o">.</span><span class="n">sub_right_side_into</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span>
        
        <span class="c1"># Else neither the start_idx nor the end_idx has been specified,</span>
        <span class="c1"># indicating we intend to combine all possible factors, either:</span>
        <span class="c1"># (1) all like-bases combined with a single exponent, such as</span>
        <span class="c1">#     a^b a^c a^d = a^{b+c+d},</span>
        <span class="c1"># OR</span>
        <span class="c1"># (2) all like-exponents</span>
        <span class="c1">#     a^z b^z c^z = (abc)^z</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># [*]() = 1</span>
            <span class="k">return</span> <span class="n">empty_mult</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ExprRange</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_parameter_independent</span><span class="p">):</span>
            <span class="c1"># x * x * ..(n-3)x.. * x = x^n</span>
            <span class="n">factor_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">factor_range</span><span class="o">.</span><span class="n">body</span>                    
            <span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">factor_range</span><span class="o">.</span><span class="n">start_index</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
                <span class="c1"># Transform from as ExprRange that start at 1.</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor_range</span><span class="o">.</span><span class="n">reduction</span><span class="p">()</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">())</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_nat_pos_rev</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">n</span><span class="p">:</span><span class="n">_n</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">_x</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">inst</span>
        
        <span class="n">factors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">):</span>
            <span class="c1"># The factors are all numerical rational numbers, so</span>
            <span class="c1"># just evaluate the product.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
        <span class="c1"># Determine the base and the exponents to combine.</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
        <span class="n">factor_bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">factor_exponents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exponent_number_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">temp_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">disassoc_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
                    <span class="c1"># x^{n_1} * ... * x^{n_k}</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">parameter</span> <span class="ow">in</span> <span class="n">free_vars</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
                        <span class="n">base</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># signal a problem</span>
                    <span class="c1"># n_1, ..., n_k:</span>
                    <span class="n">exponent</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span>
                            <span class="n">factor</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> <span class="n">factor</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                            <span class="n">factor</span><span class="o">.</span><span class="n">start_index</span><span class="p">,</span> <span class="n">factor</span><span class="o">.</span><span class="n">end_index</span><span class="p">)</span>
                    <span class="n">exponent_number_set</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span>
                            <span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
                    <span class="n">temp_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># x^n = x * x * ..(n-3)x.. * x</span>
                    <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">combining_exponents</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">derive_reversed</span><span class="p">())</span>
                    <span class="n">temp_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replacements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
                    <span class="n">disassoc_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="c1"># exponent = factor.num_elements()</span>
                    <span class="n">exponent</span> <span class="o">=</span> <span class="n">replacements</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">exponent</span>
                    <span class="n">exponent_number_set</span> <span class="o">=</span> <span class="n">NaturalPos</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
                <span class="n">exponent</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span>
                <span class="n">exponent_number_set</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span>
                        <span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
                <span class="n">temp_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Exploit a^1 = a.</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">factor</span>
                <span class="n">exponent</span> <span class="o">=</span> <span class="n">one</span>
                <span class="n">exponent_number_set</span> <span class="o">=</span> <span class="n">NaturalPos</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">power_of_one_reduction</span><span class="p">())</span>
                <span class="n">temp_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="n">factor_bases</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">factor_exponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span>
            <span class="n">exponent_number_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exponent_number_set</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_bases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to combine exponents because &quot;</span>
                                 <span class="s2">&quot;exponential bases differ: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">temp_factors</span> <span class="o">!=</span> <span class="n">factors</span><span class="p">:</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">multi_disassociation</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">temp_factors</span><span class="p">),</span>
                            <span class="o">*</span><span class="n">disassoc_indices</span><span class="p">))</span>
        <span class="n">minimal_exponent_ns</span> <span class="o">=</span> <span class="n">union_number_set</span><span class="p">(</span><span class="o">*</span><span class="n">exponent_number_sets</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_bases</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">factor_bases</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span> <span class="o">=</span> <span class="n">factor_exponents</span>
            <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">product_of_posnat_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">_c</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">product_of_pos_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span><span class="n">_c</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">product_of_real_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span><span class="n">_c</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">product_of_complex_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span><span class="n">_c</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">(</span><span class="o">*</span><span class="n">factor_exponents</span><span class="p">)</span>
            <span class="n">_m</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">products_of_posnat_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span><span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span><span class="n">_b</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">products_of_pos_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span><span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">minimal_exponent_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">products_of_real_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span><span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">products_of_complex_powers</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span><span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>

    <span class="nd">@auto_equality_prover</span><span class="p">(</span><span class="s1">&#39;combined_operands&#39;</span><span class="p">,</span> <span class="s1">&#39;combine_operands&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">combining_operands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Combine factors, adding their literal, rational exponents.</span>
<span class="sd">        Alias for `combining_exponents`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combining_exponents</span><span class="p">()</span>    

    <span class="nd">@auto_equality_prover</span><span class="p">(</span><span class="s1">&#39;common_power_extracted&#39;</span><span class="p">,</span> <span class="s1">&#39;common_power_extract&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">common_power_extraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">exp_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive and return this Mult expression equated to the</span>
<span class="sd">        expression in which some or all of the exponential factors</span>
<span class="sd">        in which a common factor occurs in the exponent, have been</span>
<span class="sd">        grouped and rewritten to be raised as a group to that common</span>
<span class="sd">        power.</span>
<span class="sd">        For example:</span>
<span class="sd">        |- a^c b^c    = (a b)^c</span>
<span class="sd">        |- a^{c d} b^{c k} = (a^{d} b^{k})^c</span>
<span class="sd">        This also should work more generally with more than 2 factors,</span>
<span class="sd">        for example taking a^k b^k c^k to</span>
<span class="sd">        |- (a^k b^k c^k) = (a b c)^k (Careful here  makes clear we need special cases!)</span>
<span class="sd">        The start_idx and end_idx can be used to apply the process to</span>
<span class="sd">        a contiguous subset of factors within a larger set of factors.</span>
<span class="sd">        Does NOT automatically attempt to reduce a resulting new</span>
<span class="sd">        product.</span>
<span class="sd">        Planned but not implemented: allow user to specify non-</span>
<span class="sd">        contiguous factors to combine. For example, given self as</span>
<span class="sd">        a^k b^c d^k e^d</span>
<span class="sd">        allow user to specify indices 0, 2 to produce something like</span>
<span class="sd">        |- a^k b^c d^k e^d = (a d)^k b^c e^d</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Exp</span>

        <span class="n">error_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># If the start_idx and/or end_idx has been specified</span>
        <span class="k">if</span> <span class="n">start_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Compensate for potential missing indices in this block:</span>
            <span class="c1"># omission of either start or end idx defaults to a pair</span>
            <span class="c1"># of contiguous multiplicands</span>
            <span class="c1"># ALSO should eventually check that the given indices</span>
            <span class="c1"># do NOT constitute the entire Mult expression; if we are</span>
            <span class="c1"># dealing with the entire expression, then the association</span>
            <span class="c1"># step should not be necessary (?)</span>
            <span class="k">if</span> <span class="n">end_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">start_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">assoc_length</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># associate the factors intended for combination</span>
            <span class="c1"># warning: 2nd arg of association() fxn is length not index</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">assoc_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span><span class="o">.</span><span class="n">as_int</span><span class="p">()):</span>
                <span class="c1"># we have (inadvertently?) selected the entire expr,</span>
                <span class="c1"># so don&#39;t group factors; just call the same method</span>
                <span class="c1"># without specifying the indices</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_power_extraction</span><span class="p">(</span><span class="n">exp_factor</span><span class="o">=</span><span class="n">exp_factor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">association</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">assoc_length</span><span class="p">,)</span>
            <span class="c1"># isolate the targeted factors and combine them as desired</span>
            <span class="c1"># using call to this same method</span>
            <span class="n">inner_combination</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">grouped</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span><span class="o">.</span>
                    <span class="n">common_power_extraction</span><span class="p">(</span><span class="n">exp_factor</span><span class="o">=</span><span class="n">exp_factor</span><span class="p">))</span>
            <span class="c1"># substitute the combined factors back into the</span>
            <span class="c1"># grouped expression and return the deduced equality</span>
            <span class="k">return</span> <span class="n">inner_combination</span><span class="o">.</span><span class="n">sub_right_side_into</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span>

        <span class="c1"># Else neither the start_idx nor the end_idx has been specified,</span>
        <span class="c1"># indicating we intend to extract a common factor from all</span>
        <span class="c1"># the exponents of all exponential factors, like this:</span>
        <span class="c1">#     a^{i z} b^{j z} c^{k z} = (a^i b^j c^k)^z</span>
        <span class="c1"># for the moment assuming we have all exponential factors of</span>
        <span class="c1"># the form Exp(a, b) instead of something like a^b * a</span>
        <span class="c1"># NOTE: would be nice to generalize to deal with</span>
        <span class="c1"># exp_factor = None case, where we then search for and extract</span>
        <span class="c1"># ALL factors that all the exponents have in common.</span>
        <span class="c1"># For now, assume that exp_factor is NOT None.</span>
        <span class="k">if</span> <span class="n">exp_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;common_power_extraction()&#39; not implemented for &quot;</span>
                    <span class="s2">&quot;cases in which kwarg exp_factor is not supplied.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)):</span>
            <span class="c1"># then we are dealing with factors that are ALL explicit</span>
            <span class="c1"># exponentials of the form a^k.</span>
            <span class="n">factor_bases</span> <span class="o">=</span> <span class="p">[</span><span class="n">factor</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">]</span>
            <span class="n">factor_exponents</span> <span class="o">=</span> <span class="p">[</span><span class="n">factor</span><span class="o">.</span><span class="n">exponent</span> <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">]</span>

            <span class="c1"># (1) Simple case such as a^d b^d c^d, consisting of</span>
            <span class="c1"># exponential factors all of which have the same single</span>
            <span class="c1"># exponent. The more general case further below might</span>
            <span class="c1"># then re-call this sub-method after processing the factors.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">factor_exponents</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Same exponent: equate a^c b^c = (a b)^c</span>
                <span class="c1"># Combining the exponents in this case is the reverse</span>
                <span class="c1"># of distributing an exponent.</span>
                <span class="n">_new_prod</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">factor_bases</span><span class="p">)</span>
                <span class="n">_new_exp</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">_new_prod</span><span class="p">,</span> <span class="n">factor_exponents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">auto_simplify</span><span class="p">:</span>
                    <span class="n">_new_exp_simp</span> <span class="o">=</span> <span class="n">_new_exp</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">_new_exp_simp</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">_new_exp_simp</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
                       <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_new_exp_simp</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_new_exp</span><span class="o">.</span><span class="n">distribution</span><span class="p">()</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">(</span>
                            <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">the_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;An Exception! All factors appeared to &quot;</span>
                        <span class="s2">&quot;have the same exponent, but the Exp.distribution() &quot;</span>
                        <span class="s2">&quot;attempt failed with the following error message: &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">the_exception</span><span class="p">))</span>

            <span class="c1"># (2) More complex case such as a^{fd} b^{dg} c^{dg},</span>
            <span class="c1"># consisting of exponential factors, the exponents of which</span>
            <span class="c1"># have the exp_factor as a factor somewhere. Strategy is</span>
            <span class="c1"># to factor out that exponent factor in each Mult factor,</span>
            <span class="c1"># then re-call the common_power_extraction() method on the</span>
            <span class="c1"># result, and Case (1) will then handle it.</span>
            <span class="c1"># This also handles the more general case of something like</span>
            <span class="c1"># a^d b^{dg}, where the exp_factor of &#39;d&#39; might be a factor</span>
            <span class="c1"># in an exponent OR might be a stand-alone exponent</span>
            <span class="n">temp_expr</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">temp_expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span><span class="o">.</span><span class="n">as_int</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">temp_expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="n">exp_factor</span><span class="p">:</span>
                    <span class="n">temp_expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="n">temp_expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                            <span class="o">.</span><span class="n">exp_factorization</span><span class="p">(</span><span class="n">exp_factor</span><span class="p">))</span>
            <span class="c1"># eq.relation now has each factor with the specified the_factor</span>
            <span class="c1"># extracted to produce something along the lines of</span>
            <span class="c1"># |- a^{f j} b^{j, k} = (a^f)^j (b^k)^j</span>
            <span class="c1"># this now corresponds to case (1) above, so we should be able</span>
            <span class="c1"># to call this method again to handle that:</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp_expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">common_power_extraction</span><span class="p">(</span>
                    <span class="n">exp_factor</span><span class="o">=</span><span class="n">exp_factor</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;Mult.common_power_extraction()&#39; method works only &quot;</span>
                    <span class="s2">&quot;when all the specified multiplicands are instances &quot;</span>
                    <span class="s2">&quot;of Exp (i.e. each factor must be an exponential). &quot;</span>
                    <span class="s2">&quot;The method was instead called on the expression &quot;</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Mult.commutation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.commutation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;commuted&#39;</span><span class="p">,</span> <span class="s1">&#39;commute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">commutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">final_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal</span>
<span class="sd">        to a form in which the operand at index init_idx has been moved</span>
<span class="sd">        to final_idx.</span>
<span class="sd">        For example, (a  b  ...  y  z) = (a  ...  y  b  z)</span>
<span class="sd">        via init_idx = 1 and final_idx = -2.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">commutation</span><span class="p">,</span> <span class="n">leftward_commutation</span><span class="p">,</span> <span class="n">rightward_commutation</span>
        <span class="k">return</span> <span class="n">apply_commutation_thm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">commutation</span><span class="p">,</span>
            <span class="n">leftward_commutation</span><span class="p">,</span> <span class="n">rightward_commutation</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mult.group_commutation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.group_commutation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;group_commuted&#39;</span><span class="p">,</span> <span class="s1">&#39;group_commute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">group_commutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
                          <span class="n">disassociate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal</span>
<span class="sd">        to a form in which the operands at indices</span>
<span class="sd">        [init_idx, init_idx+length) have been moved to</span>
<span class="sd">        [final_idx. final_idx+length).</span>
<span class="sd">        It will do this by performing association first.</span>
<span class="sd">        If disassocate is True, it will be disassociated afterwards.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">group_commutation</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">disassociate</span><span class="o">=</span><span class="n">disassociate</span><span class="p">)</span></div>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;moved&#39;</span><span class="p">,</span> <span class="s1">&#39;move&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">permutation_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">final_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal </span>
<span class="sd">        to a form in which the operand</span>
<span class="sd">        at index init_idx has been moved to final_idx.</span>
<span class="sd">        For example, (a  b  ...  y  z) = (a  ...  y  b  z)</span>
<span class="sd">        via init_idx = 1 and final_idx = -2.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span><span class="n">init_idx</span><span class="o">=</span><span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="o">=</span><span class="n">final_idx</span><span class="p">)</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;permuted&#39;</span><span class="p">,</span> <span class="s1">&#39;permute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cycles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this Add expression is equal to an Add in which</span>
<span class="sd">        the terms at indices 0, 1, , n-1 have been reordered as</span>
<span class="sd">        specified EITHER by the new_order list OR by the cycles list</span>
<span class="sd">        parameter. For example,</span>
<span class="sd">            (abcd).permutation_general(new_order=[0, 2, 3, 1])</span>
<span class="sd">        and</span>
<span class="sd">            (abcd).permutation_general(cycles=[(1, 2, 3)])</span>
<span class="sd">        would both return  (abcd) = (acdb).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">generic_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>
    
<div class="viewcode-block" id="Mult.association"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.association">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;associated&#39;</span><span class="p">,</span> <span class="s1">&#39;associate&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal</span>
<span class="sd">        to a form in which operands in the</span>
<span class="sd">        range [start_idx, start_idx+length) are grouped together.</span>
<span class="sd">        For example, (a * b * ... * y * z) =</span>
<span class="sd">            (a * b ... * (l * ... * m) * ... * y * z)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">association</span>
        <span class="k">return</span> <span class="n">apply_association_thm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">association</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mult.disassociation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Mult.html#proveit.numbers.Mult.disassociation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;disassociated&#39;</span><span class="p">,</span> <span class="s1">&#39;disassociate&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">disassociation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal</span>
<span class="sd">        to a form in which the operand</span>
<span class="sd">        at index idx is no longer grouped together.</span>
<span class="sd">        For example, (a * b ... * (l * ... * m) * ... * y* z)</span>
<span class="sd">            = (a * b * ... * y * z)</span>
<span class="sd">        Multiple indices can be provided for multiple disassociations</span>
<span class="sd">        simultaneously, e.g. expr.disassociation(2, 3, 4)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">disassociation</span>
        <span class="k">return</span> <span class="n">apply_disassociation_thm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">disassociation</span><span class="p">)</span></div>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_via_operand_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand_relation</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Alias for bound_via_factor_bound.</span>
<span class="sd">        Also see NumberOperation.deduce_bound.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_via_factor_bound</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_via_factor_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_relation</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce a bound of this multiplication via the bound on</span>
<span class="sd">        one of its factors.  For example</span>
<span class="sd">            a*b*c*d &lt; a*z*c*d   given   b &lt; z and a, c, d positive.</span>

<span class="sd">        Also see NumberOperation.deduce_bound.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">NumberOrderingRelation</span><span class="p">,</span>
                                     <span class="n">Less</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span> <span class="n">greater_eq</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_relation</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="n">factor_relation</span> <span class="o">=</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_relation</span><span class="p">,</span> <span class="n">NumberOrderingRelation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;factor_relation&#39; expected to be a number &quot;</span>
                            <span class="s2">&quot;relation (&lt;, &gt;, , or )&quot;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">also_return_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;factor_relation&#39; expected to be a relation &quot;</span>
                            <span class="s2">&quot;for one of the factors; neither factor of </span><span class="si">%s</span><span class="s2"> &quot;</span>
                            <span class="s2">&quot;appears in the </span><span class="si">%s</span><span class="s2"> relation.&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_relation</span><span class="p">))</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="c1"># Handle the binary cases.</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">relation</span> <span class="o">=</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">right_mult_both_sides</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">relation</span> <span class="o">=</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">left_mult_both_sides</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">relation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
                <span class="n">deduce_number_set</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">all</span><span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="k">for</span>
                        <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)):</span>
                <span class="c1"># We can use the strong bound.</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">strong_bound_via_factor_bound</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">strong_bound_via_factor_bound</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">greater_eq</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="k">for</span>
                     <span class="n">factor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">):</span>
                <span class="c1"># We may only use the weak bound.</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">weak_bound_via_factor_bound</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">weak_bound_via_factor_bound</span>
            <span class="k">if</span> <span class="n">thm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">normal_lhs</span>
                <span class="n">_y</span> <span class="o">=</span> <span class="n">factor_relation</span><span class="o">.</span><span class="n">normal_rhs</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y</span><span class="p">}))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Not so simple.  Let&#39;s make it simpler by</span>
                <span class="c1"># factoring it into a binary multiplication.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                        <span class="n">idx</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">bound_via_factor_bound</span><span class="p">(</span><span class="n">factor_relation</span><span class="p">))</span>
                <span class="c1"># Put things back as the were before the factorization.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="n">relation</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">if</span> <span class="n">relation</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">relation</span> <span class="o">=</span> <span class="n">relation</span><span class="o">.</span><span class="n">with_direction_reversed</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">relation</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">relation</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this product is greater than zero.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">greater</span>
        <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span></div>

<div class="viewcode-block" id="compose_product"><a class="viewcode-back" href="../../../../api/proveit.numbers.compose_product.html#proveit.numbers.compose_product">[docs]</a><span class="k">def</span> <span class="nf">compose_product</span><span class="p">(</span><span class="o">*</span><span class="n">factors</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return an expression representing the product of the given</span>
<span class="sd">    factors using obvious simplifications: return &#39;one&#39; if there</span>
<span class="sd">    are no factors, return the single factor if there is only 1,</span>
<span class="sd">    return &#39;zero&#39; if there are any zeros, and combine fractions.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">compose_fraction</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">one</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">numerators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">denominators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">operand</span>
            <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">numerator</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">zero</span>
            <span class="k">elif</span> <span class="n">factor</span><span class="o">.</span><span class="n">numerator</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">numerators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">)</span>
            <span class="n">denominators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">factor</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">factor</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
            <span class="n">numerators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">denominators</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">compose_product</span><span class="p">(</span><span class="o">*</span><span class="n">numerators</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sign</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span> <span class="n">numerator</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span><span class="n">numerator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">compose_fraction</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span>
                                <span class="n">compose_product</span><span class="p">(</span><span class="o">*</span><span class="n">denominators</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numerators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">one</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">numerators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numerators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">numerators</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sign</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">Neg</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>

<span class="k">def</span> <span class="nf">coefficient_and_remainder</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the coefficient and remainder of the given expression.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">is_numeric_rational</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
        <span class="c1"># Put the negation in the coefficient.</span>
        <span class="n">coef</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">coefficient_and_remainder</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">coef</span><span class="o">.</span><span class="n">operand</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="k">else</span> <span class="n">Neg</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef</span><span class="p">,</span> <span class="n">remainder</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span>
            <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="c1"># Extract a numerical coefficient if it appears at the</span>
        <span class="c1"># beginning of the Mult.</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="c1"># irreducible coef</span>
        <span class="n">num_factors</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">num_factors</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">elif</span> <span class="n">num_factors</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">one</span>
    <span class="k">elif</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="c1"># Already a numerical rational number.</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="c1"># irreducible coef</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">one</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Just the trivial coefficient of 1.</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">one</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">coef</span><span class="p">,</span> <span class="n">remainder</span>

<span class="k">def</span> <span class="nf">_add_canonical_factors</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span>
                           <span class="n">canonical_factor_exponents</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Add factors of the given expr, raised to the given exponent</span>
<span class="sd">    and put into canonical form, to &#39;canonical_factor_exponents&#39;</span>
<span class="sd">    which maps canonical factors to their exponents.</span>
<span class="sd">    When exponents are added, they are &#39;quick simplified&#39; but otherwise</span>
<span class="sd">    left in their original form.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">negated</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">Exp</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="n">_add_canonical_factors</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
        <span class="n">_add_canonical_factors</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> 
                               <span class="n">canonical_factor_exponents</span><span class="p">)</span>
        <span class="n">_add_canonical_factors</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">negated</span><span class="p">(</span><span class="n">exponent</span><span class="p">),</span> 
                               <span class="n">canonical_factor_exponents</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
        <span class="n">internal_exponent</span> <span class="o">=</span> <span class="n">compose_product</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="n">_add_canonical_factors</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">internal_exponent</span><span class="p">,</span> 
                               <span class="n">canonical_factor_exponents</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prev_exponent</span> <span class="o">=</span> <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
        <span class="n">new_exponent</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">prev_exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
        <span class="n">canonical_factor_exponents</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_exponent</span>

<div class="viewcode-block" id="remove_common_factors"><a class="viewcode-back" href="../../../../api/proveit.numbers.remove_common_factors.html#proveit.numbers.remove_common_factors">[docs]</a><span class="k">def</span> <span class="nf">remove_common_factors</span><span class="p">(</span><span class="n">expr_A</span><span class="p">,</span> <span class="n">expr_B</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the portion of expr_A that remains after removing the</span>
<span class="sd">    factors that are in common with expr_B.  Canonical forms are used</span>
<span class="sd">    to determine which factors are in common, but the returned portion</span>
<span class="sd">    of expr_A will be kept in its original form.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Get the factors of expr_B in canonical form and their </span>
    <span class="c1"># net exponents.</span>
    <span class="n">canonical_factor_exponents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">_add_canonical_factors</span><span class="p">(</span><span class="n">expr_B</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">)</span>
    <span class="c1"># Iterate through factors of expr_A to see if they match with</span>
    <span class="c1"># any of the expr_B factors in canonical form.</span>
    <span class="k">return</span> <span class="n">_remove_common_factors</span><span class="p">(</span><span class="n">expr_A</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">)</span></div>
    
<span class="k">def</span> <span class="nf">_remove_common_factors</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return this expression after removing factors that appear in</span>
<span class="sd">    &#39;canonical_factor_exponents&#39; and remove those from</span>
<span class="sd">    &#39;canonical_factor_exponents&#39; as well.  Called recursively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">subtract</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">Exp</span><span class="p">,</span>
                                 <span class="n">readily_factorable</span><span class="p">,</span> <span class="n">compose_fraction</span><span class="p">)</span>
    <span class="n">expr_cf</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">expr_cf</span> <span class="ow">in</span> <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span> <span class="c1"># handle this below in the Exp case</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
        <span class="n">remaining_factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
            <span class="c1"># Recursively remove common factors from this</span>
            <span class="c1"># &#39;factor&#39; of self.</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">_remove_common_factors</span><span class="p">(</span>
                            <span class="n">factor</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">factor</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">remaining_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="c1"># Return a new product of the remaining factors.</span>
        <span class="k">return</span> <span class="n">compose_product</span><span class="p">(</span><span class="o">*</span><span class="n">remaining_factors</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
        <span class="c1"># Recursively remove common factors from the numerator.</span>
        <span class="n">remaining_numerator</span> <span class="o">=</span> <span class="n">_remove_common_factors</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">canonical_factor_exponents</span><span class="p">)</span>
        <span class="n">canonical_factor_negated_exponents</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">factor</span><span class="p">:</span> <span class="n">Add</span><span class="p">(</span><span class="n">Neg</span><span class="p">(</span><span class="n">exponent</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">factor</span><span class="p">,</span> <span class="n">exponent</span> <span class="ow">in</span> <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># Recursively remove common factors, with negated exponents,</span>
        <span class="c1"># from the denominator.</span>
        <span class="n">remaining_denominator</span> <span class="o">=</span> <span class="n">_remove_common_factors</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">canonical_factor_negated_exponents</span><span class="p">)</span>
        <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">factor</span><span class="p">:</span> <span class="n">Add</span><span class="p">(</span><span class="n">Neg</span><span class="p">(</span><span class="n">exponent</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">factor</span><span class="p">,</span> <span class="n">exponent</span> 
                <span class="ow">in</span> <span class="n">canonical_factor_negated_exponents</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">if</span> <span class="n">remaining_denominator</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="c1"># trivial deonominator</span>
            <span class="k">return</span> <span class="n">remaining_numerator</span>
        <span class="c1"># Return a new fraction.</span>
        <span class="k">return</span> <span class="n">Div</span><span class="p">(</span><span class="n">remaining_numerator</span><span class="p">,</span> <span class="n">remaining_denominator</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
        <span class="c1"># e.g., expr = a^b</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">exponent</span>
        <span class="n">base_cf</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">base_cf</span> <span class="ow">in</span> <span class="n">canonical_factor_exponents</span><span class="p">:</span>
            <span class="n">factor_exponent</span> <span class="o">=</span> <span class="n">canonical_factor_exponents</span><span class="p">[</span><span class="n">base_cf</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">factor_exponent</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="o">==</span> <span class="n">exponent</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">():</span>
                <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">base_cf</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">one</span>
            <span class="n">canonical_factor</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base_cf</span><span class="p">,</span> <span class="n">factor_exponent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">readily_factorable</span><span class="p">(</span><span class="n">canonical_factor</span><span class="p">):</span>
                <span class="c1"># Remove all of some a^c from a^b to leave</span>
                <span class="c1"># a^{b - c}</span>
                <span class="n">new_exponent</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span>
                                        <span class="n">factor_exponent</span><span class="p">)</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">base_cf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">one</span>
                <span class="k">elif</span> <span class="n">new_exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">base</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">new_exponent</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="n">canonical_factor</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
                <span class="c1"># Use the a^b part of some a^c to eliminate a^b and</span>
                <span class="c1"># leave a^{c - b} to possibly remove other factors.</span>
                <span class="n">new_exponent</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">factor_exponent</span><span class="p">,</span>
                                        <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">new_exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                    <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">base_cf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">canonical_factor_exponents</span><span class="p">[</span><span class="n">base_cf</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_exponent</span>
                <span class="k">return</span> <span class="n">one</span>
        <span class="k">if</span> <span class="n">expr_cf</span> <span class="ow">in</span> <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Avoid infinite recursion.  Unable to factor.</span>
            <span class="k">assert</span> <span class="n">expr</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span>
        <span class="c1"># Recursively remove common factors, with altered exponents,</span>
        <span class="c1"># within the base.</span>
        <span class="n">canonical_factor_adjusted_exponents</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">factor</span><span class="p">:</span> <span class="n">compose_fraction</span><span class="p">(</span><span class="n">_exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">factor</span><span class="p">,</span> <span class="n">_exponent</span> <span class="ow">in</span> <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">remaining_base</span> <span class="o">=</span> <span class="n">_remove_common_factors</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">canonical_factor_adjusted_exponents</span><span class="p">)</span>
        <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">canonical_factor_exponents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="n">factor</span><span class="p">:</span> <span class="n">compose_product</span><span class="p">(</span><span class="n">_exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">factor</span><span class="p">,</span> <span class="n">_exponent</span> 
                <span class="ow">in</span> <span class="n">canonical_factor_adjusted_exponents</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">if</span> <span class="n">remaining_base</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span>
        <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">remaining_base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expression.html">as_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expressions.html">as_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_equality_prover.html">auto_equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_prover.html">auto_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_relation_prover.html">auto_relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.composite_expression.html">composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.equality_prover.html">equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.expression_depth.html">expression_depth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_var_ranges.html">free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.generate_inner_expressions.html">generate_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.horiz_var_array.html">horiz_var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced.html">maybe_fenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_latex.html">maybe_fenced_latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_string.html">maybe_fenced_string</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.prover.html">prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.relation_prover.html">relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_default_or_dummy_var.html">safe_default_or_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_var.html">safe_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_vars.html">safe_dummy_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_index.html">simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_indices.html">simplified_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.single_or_composite_expression.html">single_or_composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.total_ordering.html">total_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_literals.html">used_literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_array.html">var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_range.html">var_range</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.vert_var_array.html">vert_var_array</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composition.html">Composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ConditionalSet.html">ConditionalSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Deduction.html">Deduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExprGenerator.html">InnerExprGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Judgment.html">Judgment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterMaskingError.html">ParameterMaskingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterRelabelingError.html">ParameterRelabelingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.SimplificationDirectives.html">SimplificationDirectives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryException.html">TheoryException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryPackage.html">TheoryPackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnsatisfiedPrerequisites.html">UnsatisfiedPrerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnusableProof.html">UnusableProof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Variable.html">Variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.VertExprArray.html">VertExprArray</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.core_expr_types.Len.html">Len</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.conclude_via_implication.html">conclude_via_implication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.deduce_equal_or_not.html">deduce_equal_or_not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_falsehood.html">evaluate_falsehood</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_truth.html">evaluate_truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluation_or_simplification.html">evaluation_or_simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.in_bool.html">in_bool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.is_irreducible_value.html">is_irreducible_value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_proper_superset.html">not_proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_superset_eq.html">not_superset_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.proper_superset.html">proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.superset_eq.html">superset_eq</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Bijections.html">Bijections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.BooleanSet.html">BooleanSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartExp.html">CartExp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartProd.html">CartProd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassMembership.html">ClassMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassNonmembership.html">ClassNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.FalseLiteral.html">FalseLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InClass.html">InClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Injections.html">Injections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IntersectAll.html">IntersectAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InvImage.html">InvImage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInClass.html">NotInClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotProperSubset.html">NotProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.PowerSet.html">PowerSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ProperSubset.html">ProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetEquiv.html">SetEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetMembership.html">SetMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNonmembership.html">SetNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNotEquiv.html">SetNotEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.StrictSubset.html">StrictSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetProper.html">SubsetProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Surjections.html">Surjections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.TrueLiteral.html">TrueLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Union.html">Union</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UnionAll.html">UnionAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UniqueExists.html">UniqueExists</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.complex_polar_coordinates.html">complex_polar_coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_fraction.html">compose_fraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_product.html">compose_product</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_as_mon_dec_func.html">deduce_as_mon_dec_func</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_in_number_set.html">deduce_in_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_not_equal_numeric_rationals.html">deduce_not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_number_set.html">deduce_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.exp2pi_i.html">exp2pi_i</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater.html">greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater_eq.html">greater_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_int.html">is_numeric_int</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_natural.html">is_numeric_natural</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_rational.html">is_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_ints.html">less_eq_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_rationals.html">less_eq_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_ints.html">less_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_rationals.html">less_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.negated.html">negated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.not_equal_numeric_rationals.html">not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.number_ordering.html">number_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.numeric_rational_ints.html">numeric_rational_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.quick_simplified_index.html">quick_simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_factorable.html">readily_factorable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_provable_number_set.html">readily_provable_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.remove_common_factors.html">remove_common_factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.simplified_numeric_rational.html">simplified_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrd.html">sqrd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.standard_number_set.html">standard_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.subtract.html">subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.union_number_set.html">union_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.unit_length_complex_polar_angle.html">unit_length_complex_polar_angle</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.BinarySequence.html">BinarySequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Conjugate.html">Conjugate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DividesProper.html">DividesProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.KroneckerDelta.html">KroneckerDelta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Log.html">Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.MonDecFuncs.html">MonDecFuncs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOperation.html">NumberOperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOrderingRelation.html">NumberOrderingRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>