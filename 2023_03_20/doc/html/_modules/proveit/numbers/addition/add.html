
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>proveit.numbers.addition.add &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<header>These are archival webpages, generated on 2023-03-20 by <a href="https://github.com/sandialabs/Prove-It">Prove-It</a> Beta Version 0.3, licensed under the GNU Public Licence by Sandia Corporation.  See <a href="http://pyproveit.org">pyproveit.org</a> for the lastest version.</header>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit.numbers.addition.add</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">Counter</span>

<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="p">(</span><span class="n">Expression</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Operation</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">,</span>
                     <span class="n">ExprRange</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">StyleOptions</span><span class="p">,</span> 
                     <span class="n">prover</span><span class="p">,</span> <span class="n">relation_prover</span><span class="p">,</span> <span class="n">equality_prover</span><span class="p">,</span>
                     <span class="n">auto_prover</span><span class="p">,</span> <span class="n">auto_relation_prover</span><span class="p">,</span> <span class="n">auto_equality_prover</span><span class="p">,</span>
                     <span class="n">maybe_fenced_latex</span><span class="p">,</span> <span class="n">ProofFailure</span><span class="p">,</span> <span class="n">InnerExpr</span><span class="p">,</span>
                     <span class="n">UnsatisfiedPrerequisites</span><span class="p">,</span>
                     <span class="n">SimplificationDirectives</span><span class="p">,</span> <span class="n">TransRelUpdater</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.util</span> <span class="k">import</span> <span class="n">OrderedSet</span>
<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">free_vars</span>
<span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="p">(</span><span class="n">And</span><span class="p">,</span> <span class="n">Equals</span><span class="p">,</span> <span class="n">NotEquals</span><span class="p">,</span>
                           <span class="n">EvaluationError</span><span class="p">,</span> <span class="n">InSet</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.logic.irreducible_value</span> <span class="k">import</span> <span class="n">is_irreducible_value</span>
<span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">NumberOperation</span><span class="p">,</span> <span class="n">standard_number_set</span><span class="p">,</span>
                             <span class="n">pos_number_set</span><span class="p">,</span> <span class="n">neg_number_set</span><span class="p">,</span> 
                             <span class="n">nonneg_number_set</span><span class="p">,</span> <span class="n">nonpos_number_set</span><span class="p">,</span>
                             <span class="n">nonzero_number_set</span><span class="p">,</span>
                             <span class="n">union_number_set</span><span class="p">,</span> <span class="n">deduce_number_set</span><span class="p">,</span>
                             <span class="n">readily_provable_number_set</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.numbers.numerals.decimals</span> <span class="k">import</span> <span class="n">DIGITS</span>
<span class="kn">import</span> <span class="nn">proveit.numbers.numerals.decimals</span>
<span class="kn">from</span> <span class="nn">proveit.abstract_algebra.generic_methods</span> <span class="k">import</span> <span class="p">(</span>
        <span class="n">apply_commutation_thm</span><span class="p">,</span> <span class="n">apply_association_thm</span><span class="p">,</span> 
        <span class="n">apply_disassociation_thm</span><span class="p">,</span> <span class="n">group_commutation</span><span class="p">,</span> <span class="n">pairwise_evaluation</span><span class="p">,</span>
        <span class="n">deduce_equality_via_commutation</span><span class="p">,</span> <span class="n">generic_permutation</span><span class="p">,</span>
        <span class="n">sorting_operands</span><span class="p">,</span> <span class="n">sorting_and_combining_like_operands</span><span class="p">,</span>
        <span class="n">common_likeness_key</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">TransRelUpdater</span>
<span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">ZeroSet</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">IntegerNeg</span><span class="p">,</span> <span class="n">IntegerNonPos</span><span class="p">,</span>
                             <span class="n">Natural</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">,</span> <span class="n">IntegerNonZero</span><span class="p">,</span>
                             <span class="n">Rational</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span> <span class="n">RationalNonZero</span><span class="p">,</span>
                             <span class="n">RationalNeg</span><span class="p">,</span> <span class="n">RationalNonNeg</span><span class="p">,</span>
                             <span class="n">RationalNonPos</span><span class="p">,</span>
                             <span class="n">Real</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span>
                             <span class="n">RealNonPos</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> 
                             <span class="n">ComplexNonZero</span><span class="p">)</span>


<div class="viewcode-block" id="Add"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add">[docs]</a><span class="k">class</span> <span class="nc">Add</span><span class="p">(</span><span class="n">NumberOperation</span><span class="p">):</span>
    <span class="c1"># operator of the Add operation</span>
    <span class="n">_operator_</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">string_format</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="vm">__file__</span><span class="p">)</span>
    
    <span class="c1"># The &#39;order_key&#39; simplification directive can be used</span>
    <span class="c1"># to sort terms in a particular order.  By default, there</span>
    <span class="c1"># is no sorting -- it keeps the original order as much as</span>
    <span class="c1"># possible but still combines like terms.</span>
    <span class="n">_simplification_directives_</span> <span class="o">=</span> <span class="n">SimplificationDirectives</span><span class="p">(</span>
            <span class="n">ungroup</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">combine_like_terms</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">combine_like_denoms</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">order_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">term</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add together any number of operands.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">NumberOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Add</span><span class="o">.</span><span class="n">_operator_</span><span class="p">,</span> <span class="n">operands</span><span class="p">,</span> 
                                 <span class="n">styles</span><span class="o">=</span><span class="n">styles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_isNegatedOperand</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns True iff the given operand is negated directly or an iteration with a negated body</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">operand</span><span class="p">,</span>
            <span class="n">Neg</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">operand</span><span class="p">,</span>
                <span class="n">ExprRange</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="p">,</span>
                <span class="n">Neg</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_formatted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Override Operation._formatted so to enable subtraction notation where desired.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">ExprRange</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        
        <span class="c1"># Where should we use subtraction notation </span>
        <span class="n">subtraction_positions</span> <span class="o">=</span> <span class="p">[]</span>        
        <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">use_subtraction_notation</span><span class="p">():</span>
                    <span class="n">subtraction_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_k</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">operand</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">use_subtraction_notation</span><span class="p">():</span>
                        <span class="n">subtraction_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_k</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtraction_positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="c1"># Make the operator an ExprRange in correspondence</span>
                    <span class="c1"># with the operands ExprRange</span>
                    <span class="n">operators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">ExprRange</span><span class="p">(</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter_or_parameters</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">operators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>
            <span class="n">implicit_first_operator</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># the first operator is implicit if it is a &#39;+&#39;</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">subtraction_positions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">operand</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">implicit_first_operator</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="c1"># format negated operand using subtraction notation</span>
                    <span class="n">operators</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">Neg</span><span class="o">.</span><span class="n">_operator_</span>
                    <span class="n">operands</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">operand</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                        <span class="c1"># format iteration with negation using subtraction</span>
                        <span class="c1"># notation</span>
                        <span class="n">operators</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span>
                            <span class="n">Neg</span><span class="o">.</span><span class="n">_operator_</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                        <span class="n">operands</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                            <span class="n">operand</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span> <span class="o">.</span><span class="n">with_styles</span><span class="p">(</span>
                            <span class="o">**</span><span class="n">operand</span><span class="o">.</span><span class="n">get_styles</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># not negated after all -- revert to the &quot;implicit first</span>
                    <span class="c1"># operator&quot; default</span>
                    <span class="n">implicit_first_operator</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">_formatted_operation</span><span class="p">(</span>
                <span class="n">format_type</span><span class="p">,</span>
                <span class="n">operators</span><span class="p">,</span>
                <span class="n">operands</span><span class="p">,</span>
                <span class="n">implicit_first_operator</span><span class="o">=</span><span class="n">implicit_first_operator</span><span class="p">,</span>
                <span class="n">wrap_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_positions</span><span class="p">(),</span>
                <span class="n">justification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;justification&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">_formatted_operation</span><span class="p">(</span>
                <span class="n">format_type</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">,</span>
                <span class="n">wrap_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_positions</span><span class="p">(),</span>
                <span class="n">justification</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;justification&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">),</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Add.remake_constructor"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.remake_constructor">[docs]</a>    <span class="k">def</span> <span class="nf">remake_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">use_subtraction_notation</span><span class="p">()):</span>
            <span class="k">return</span> <span class="s1">&#39;subtract&#39;</span>  <span class="c1"># use a different constructor if using the subtraction style</span>
        <span class="k">return</span> <span class="n">Operation</span><span class="o">.</span><span class="n">remake_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Add.remake_arguments"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.remake_arguments">[docs]</a>    <span class="k">def</span> <span class="nf">remake_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yield the argument values or (name, value) pairs</span>
<span class="sd">        that could be used to recreate the Operation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">use_subtraction_notation</span><span class="p">()):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">),</span> <span class="s2">&quot;The second operand must be negated&quot;</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">operand</span></div>

<div class="viewcode-block" id="Add.equality_side_effects"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.equality_side_effects">[docs]</a>    <span class="k">def</span> <span class="nf">equality_side_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">judgment</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If the right side is irreducible and the left side is</span>
<span class="sd">        binary, a + b = c, derive the commutation</span>
<span class="sd">            b + a = c</span>
<span class="sd">        and if neither a nor b is a Neg, also derive the following:</span>
<span class="sd">            -a - b = -c</span>
<span class="sd">            c - b = a</span>
<span class="sd">            b - c = -a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">judgment</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting &#39;judgment&#39; to be a Judgment.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">judgment</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting the judgment to be an equality.&quot;</span><span class="p">)</span>
        <span class="n">addition</span> <span class="o">=</span> <span class="n">judgment</span><span class="o">.</span><span class="n">lhs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addition</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expecting lhs of judgment to be of an Add expression.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">judgment</span><span class="o">.</span><span class="n">rhs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">addition</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="c1"># deduce the commutation form: b+a=c from a+b=c</span>
                <span class="k">if</span> <span class="n">addition</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">addition</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">judgment</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">commute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">addition</span><span class="o">.</span><span class="n">terms</span><span class="p">):</span>
                    <span class="c1"># From a+b=c</span>
                    <span class="c1"># deduce the negations form: -a-b=-c</span>
                    <span class="c1">#      the subtraction form: c-b=a</span>
                    <span class="c1">#      and the reversed subtraction form: b-c = -a</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_negation</span><span class="p">(</span><span class="n">judgment</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_subtraction</span><span class="p">(</span><span class="n">judgment</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_reversed_subtraction</span><span class="p">(</span>
                            <span class="n">judgment</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_build_canonical_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a form of this Add with operands in their canonical </span>
<span class="sd">        forms, nested addition is ungrouped, and &quot;common&quot; terms that </span>
<span class="sd">        are the same except coefficient factors are combined, and </span>
<span class="sd">        these terms are all ordered deterministically according to</span>
<span class="sd">        hash values of the non-coefficient parts of the terms.</span>
<span class="sd">        </span>
<span class="sd">        Example: (2/3)*a*b + c + 1 - (-1/4)*a*b + c + (1/3) -&gt;</span>
<span class="sd">                 (4/3) + (11/12) a*b + 2 c</span>
<span class="sd">        The order of the terms is arbitrary but deterministic</span>
<span class="sd">        (sorted by hash value).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span>
                                     <span class="n">is_numeric_rational</span><span class="p">,</span>
                                     <span class="n">numeric_rational_ints</span><span class="p">,</span>
                                     <span class="n">simplified_numeric_rational</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.multiplication.mult</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">coefficient_and_remainder</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span> <span class="c1"># Add operation with no operands</span>
        <span class="n">remainder_to_rational_coef</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">contains_only_numeric_rationals</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Generate canonical forms of terms and ungroup nested</span>
        <span class="c1"># addition:</span>
        <span class="k">def</span> <span class="nf">gen_coef_and_remainders</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="n">canonical_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="c1"># Negation should distribute through Add</span>
                    <span class="c1"># in its canonical form.</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canonical_term</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">_coeff_and_remainder</span> <span class="ow">in</span> <span class="n">gen_coef_and_remainders</span><span class="p">(</span>
                            <span class="n">canonical_term</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">_coeff_and_remainder</span>
                    <span class="c1"># for sub_term in canonical_term.terms:</span>
                    <span class="c1">#     yield coefficient_and_remainder(sub_term)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">coefficient_and_remainder</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coef</span><span class="p">,</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="n">gen_coef_and_remainders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coef</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">contains_only_numeric_rationals</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="n">remainder_to_rational_coef</span><span class="p">:</span>
                <span class="n">prev_coef</span> <span class="o">=</span> <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prev_coef</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">prev_coef</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span>
                            <span class="n">prev_coef</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remainder_to_rational_coef</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span> <span class="c1"># Add() = 0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remainder_to_rational_coef</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># special case to avoid infinite recursion</span>
            <span class="n">remainder</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">remainder_to_rational_coef</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remainder</span>
        <span class="k">if</span> <span class="n">contains_only_numeric_rationals</span><span class="p">:</span>
            <span class="c1"># This is a sum of only numeric rationals.  Just</span>
            <span class="c1"># compute it.</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">remainder_to_rational_coef</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
            <span class="k">assert</span> <span class="n">one</span> <span class="ow">in</span> <span class="n">remainder_to_rational_coef</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">one</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">expr</span>
            <span class="n">sum_as_expr</span> <span class="o">=</span> <span class="n">zero</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="c1"># Add to the cumulative sum.</span>
                <span class="c1"># (a/b) + (c/d) = (a*d + c*b)/(b*d)</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">sum_as_expr</span><span class="p">)</span>
                <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="n">sum_as_expr</span> <span class="o">=</span> <span class="n">simplified_numeric_rational</span><span class="p">(</span><span class="n">_a</span><span class="o">*</span><span class="n">_d</span><span class="o">+</span><span class="n">_c</span><span class="o">*</span><span class="n">_b</span><span class="p">,</span> <span class="n">_b</span><span class="o">*</span><span class="n">_d</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sum_as_expr</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">remainder</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">remainder_to_rational_coef</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">remainder</span><span class="o">==</span><span class="n">one</span><span class="p">:</span> 
                <span class="c1"># We&#39;ll save the constant (numeric rational) for the</span>
                <span class="c1"># last term (consistent with the &#39;quick simplified&#39; </span>
                <span class="c1"># form).</span>
                <span class="k">continue</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coef</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">coef</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">remainder</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="o">*</span><span class="n">remainder</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
            <span class="n">canonical_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canonical_term</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">one</span> <span class="ow">in</span> <span class="n">remainder_to_rational_coef</span><span class="p">:</span>
            <span class="c1"># Add the numeric rational as the last term.</span>
            <span class="n">coef</span> <span class="o">=</span> <span class="n">remainder_to_rational_coef</span><span class="p">[</span><span class="n">one</span><span class="p">]</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coef</span> <span class="o">!=</span> <span class="n">zero</span><span class="p">:</span> <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">([</span><span class="n">operand</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="k">for</span> <span class="n">operand</span> 
                           <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">hash</span><span class="p">))</span>

    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">equation_negation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From (a + b) = rhs, derive and return -(a-b) = -rhs</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.addition.subtraction</span> <span class="k">import</span> <span class="n">negated_add</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Add.equation_negation implemented only when there are two &quot;</span>
                <span class="s2">&quot;and only two added terms&quot;</span><span class="p">)</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">deduction</span> <span class="o">=</span> <span class="n">negated_add</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">rhs</span><span class="p">},</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deduction</span>

    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">equation_subtraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From (a + b) = rhs, derive and return rhs - b = a.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.addition.subtraction</span> <span class="k">import</span> <span class="n">subtract_from_add</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Add.deduce_subtraction implemented only when there are &quot;</span>
                <span class="s2">&quot;two and only two added terms&quot;</span><span class="p">)</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">deduction</span> <span class="o">=</span> <span class="n">subtract_from_add</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">rhs</span><span class="p">},</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deduction</span>

    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">equation_reversed_subtraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From (a + b) = rhs, derive and return b - rhs = -a.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.addition.subtraction</span> <span class="k">import</span> <span class="n">subtract_from_add_reversed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Add.decude_reversed_subtraction implemented only when &quot;</span>
                <span class="s2">&quot;there are two and only two added terms&quot;</span><span class="p">)</span>
        <span class="n">deduction</span> <span class="o">=</span> <span class="n">subtract_from_add_reversed</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">:</span> <span class="n">rhs</span><span class="p">},</span>
            <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deduction</span>

<div class="viewcode-block" id="Add.conversion_to_multiplication"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.conversion_to_multiplication">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;multiplied&#39;</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">conversion_to_multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From the addition of the same values, derive and return</span>
<span class="sd">        the equivalence as a multiplication. For example,</span>
<span class="sd">        a + a + a = 3 * a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">ExprRange</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">one</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.multiplication</span> <span class="k">import</span> <span class="p">(</span>
            <span class="n">mult_def_rev</span><span class="p">,</span> <span class="n">repeated_addition_to_mult</span><span class="p">)</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ExprRange</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_parameter_independent</span><span class="p">):</span>
            <span class="n">expr_range</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">true_start_index</span>
            <span class="k">if</span> <span class="n">start_index</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
                <span class="c1"># change the indexing to start from 1.</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift_equivalence</span><span class="p">(</span>
                        <span class="n">new_start</span><span class="o">=</span><span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">()</span>
                <span class="n">_n</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">true_end_index</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_n</span> <span class="o">=</span> <span class="n">expr_range</span><span class="o">.</span><span class="n">true_end_index</span>
            <span class="c1"># x + x + ..(n-3)x.. + x = x*n</span>
            <span class="k">return</span> <span class="n">repeated_addition_to_mult</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">expr_range</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">},</span>
                <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
        <span class="c1"># Obtain the first element; all other elements should equal</span>
        <span class="c1"># this.</span>
        <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_x</span> <span class="o">=</span> <span class="n">operand</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="n">operands</span>
         <span class="c1"># a1 + a2 + ..(n-3)x.. + an = x*n if each a1,a2,..,an equals x.</span>
        <span class="k">return</span> <span class="n">mult_def_rev</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">})</span></div>

<div class="viewcode-block" id="Add.cancelations"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.cancelations">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;all_canceled&#39;</span><span class="p">,</span> <span class="s1">&#39;all_cancel&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cancelations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce and return an equality between self and a form in which</span>
<span class="sd">        all simple cancellations are performed (where there are exact</span>
<span class="sd">        negations that occur).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation via </span>
        <span class="c1"># transitivities. (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">neg_operand_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="n">neg_operand_indices</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                        <span class="n">operand</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">(),</span> 
                        <span class="n">OrderedSet</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_i</span><span class="p">)</span>

        <span class="n">canceled_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">operand_cf</span> <span class="o">=</span> <span class="n">operand</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">operand_cf</span> <span class="ow">in</span> <span class="n">neg_operand_indices</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">neg_operand_indices</span><span class="p">[</span><span class="n">operand_cf</span><span class="p">]</span>
                <span class="n">_j</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># no more indices to use in the future</span>
                    <span class="n">neg_operand_indices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">operand_cf</span><span class="p">)</span>
                <span class="c1"># By finding where i and j will be inserted into the </span>
                <span class="c1"># canceled_indices array, we can figure out how much </span>
                <span class="c1"># they need to shift by to compensate for previous </span>
                <span class="c1"># cancelations.</span>
                <span class="n">i_shift</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">canceled_indices</span><span class="p">,</span> <span class="n">_i</span><span class="p">)</span>
                <span class="n">j_shift</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">canceled_indices</span><span class="p">,</span> <span class="n">_j</span><span class="p">)</span>
                <span class="c1"># Insert the last one first so we don&#39;t need to </span>
                <span class="c1"># compensate:</span>
                <span class="k">if</span> <span class="n">_i</span> <span class="o">&lt;</span> <span class="n">_j</span><span class="p">:</span>
                    <span class="n">canceled_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">j_shift</span><span class="p">,</span> <span class="n">_j</span><span class="p">)</span>
                    <span class="n">canceled_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i_shift</span><span class="p">,</span> <span class="n">_i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">canceled_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i_shift</span><span class="p">,</span> <span class="n">_i</span><span class="p">)</span>
                    <span class="n">canceled_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">j_shift</span><span class="p">,</span> <span class="n">_j</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span>
                        <span class="n">_i</span> <span class="o">-</span> <span class="n">i_shift</span><span class="p">,</span> <span class="n">_j</span> <span class="o">-</span> <span class="n">j_shift</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Add.cancelation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.cancelation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;canceled&#39;</span><span class="p">,</span> <span class="s1">&#39;cancel&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cancelation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt a simple cancelation between operands at index i and j.</span>
<span class="sd">        If one of these operands is the negation of the other, deduce</span>
<span class="sd">        and return an equality between self and a form in which these</span>
<span class="sd">        operands are canceled.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.addition.subtraction</span> <span class="k">as</span> <span class="nn">sub_pkg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="k">if</span> <span class="n">idx1</span> <span class="o">&gt;</span> <span class="n">idx2</span><span class="p">:</span>
            <span class="c1"># choose i to be less than j</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cancelation</span><span class="p">(</span><span class="n">idx2</span><span class="p">,</span> <span class="n">idx1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="n">basic_thm</span> <span class="o">=</span> <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_basic</span>
            <span class="n">triple_thms</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_12</span><span class="p">,</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_13</span><span class="p">,</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_23</span><span class="p">)</span>
            <span class="n">general_thm</span> <span class="o">=</span> <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_general</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="n">basic_thm</span> <span class="o">=</span> <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_reverse</span>
            <span class="n">triple_thms</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_21</span><span class="p">,</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_31</span><span class="p">,</span>
                <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_triple_32</span><span class="p">)</span>
            <span class="n">general_thm</span> <span class="o">=</span> <span class="n">sub_pkg</span><span class="o">.</span><span class="n">add_cancel_general_rev</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to cancel </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">; &quot;</span>
                             <span class="s2">&quot;neither is in an explicitly negated form.&quot;</span>
                             <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx2</span><span class="p">]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">basic_thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">contains_range</span><span class="p">()</span> 
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># _k is the 3rd index, completing i and j in the set {0,1,2}.</span>
            <span class="n">_k</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">])</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">triple_thms</span><span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="n">_k</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_k</span><span class="p">]})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_b</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">idx2</span><span class="p">]</span>
            <span class="n">_e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_k</span> <span class="o">=</span> <span class="n">_e</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">general_thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_k</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_d</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">_e</span><span class="p">})</span></div>

<div class="viewcode-block" id="Add.zero_eliminations"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.zero_eliminations">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;eliminated_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminate_zeros&#39;</span><span class="p">)</span>   
    <span class="k">def</span> <span class="nf">zero_eliminations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive and return this Add expression equal to a form in which</span>
<span class="sd">        all zero&#39;s are eliminated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># A convenience to allow successive update to the equation via</span>
        <span class="c1"># transitivities (starting with self=self).</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Work in reverse order so indices don&#39;t need to be updated.</span>
        <span class="k">for</span> <span class="n">rev_idx</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">operand</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="n">rev_idx</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">zero_elimination</span><span class="p">(</span>
                        <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="c1"># can&#39;t do an elimination if reduced to a single term.</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>

<div class="viewcode-block" id="Add.zero_elimination"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.zero_elimination">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;eliminated_zero&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminate_zero&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">zero_elimination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Derive and return this Add expression equal to a form in which</span>
<span class="sd">        a specific zero operand (at the given index) is eliminated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">elim_zero_left</span><span class="p">,</span> <span class="n">elim_zero_right</span><span class="p">,</span> <span class="n">elim_zero_any</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Operand at the index </span><span class="si">%d</span><span class="s2"> expected to be zero for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">elim_zero_left</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">elim_zero_right</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">elim_zero_any</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">})</span></div>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;shallow_simplified&#39;</span><span class="p">,</span> <span class="s1">&#39;shallow_simplify&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shallow_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">must_evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a proven simplification equation for this Add</span>
<span class="sd">        expression assuming the operands have been simplified.</span>
<span class="sd">        </span>
<span class="sd">        Perform a number of possible simplifications of an Add</span>
<span class="sd">        expression after the operands have been simplified.  </span>
<span class="sd">        Disassociate grouped terms, eliminate zero terms,</span>
<span class="sd">        cancel common terms that are subtracted, combine like terms,</span>
<span class="sd">        convert repeated addition to multiplication, etc.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> 
                                     <span class="n">is_numeric_int</span><span class="p">,</span>
                                     <span class="n">is_numeric_rational</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.multiplication.mult</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">coefficient_and_remainder</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">empty_addition</span><span class="p">,</span> <span class="n">unary_add_reduction</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># [+]() = 0</span>
            <span class="k">return</span> <span class="n">empty_addition</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_single</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">unary_add_reduction</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                                                    <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If all operands are negated, factor out the negation.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
            <span class="n">negated</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span>
                <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">operand</span><span class="o">.</span><span class="n">operand</span> <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">]))</span>
            <span class="n">neg_distribution</span> <span class="o">=</span> <span class="n">negated</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">neg_factored</span> <span class="o">=</span> <span class="n">neg_distribution</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">neg_factored</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># for convenience updating our equation</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">Add</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">ungroup</span><span class="p">:</span>
            <span class="c1"># ungroup the expression (disassociate nested additions).</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># loop through all operands</span>
            <span class="k">while</span> <span class="n">_n</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">:</span>
                <span class="n">operand</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">operand</span><span class="o">.</span><span class="n">is_parameter_independent</span><span class="p">):</span>
                    <span class="c1"># A range of repeated terms may be simplified to</span>
                    <span class="c1"># a multiplication, but we need to group it first.</span>
                    <span class="n">inner_simplification</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">Add</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">())</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                            <span class="n">_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="p">[</span><span class="n">inner_simplification</span><span class="p">],</span>
                            <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="ow">and</span>
                         <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">))):</span>
                    <span class="c1"># if it is grouped, ungroup it</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span>
                            <span class="n">_n</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                <span class="n">_n</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># See if there are any parameter-independent expression</span>
        <span class="c1"># ranges to be converted to multiplication:</span>
        <span class="c1">#  x + x + ..(n-3)x.. + x = x*n</span>
        <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">operand</span><span class="o">.</span><span class="n">is_parameter_independent</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">conversion_to_multiplication</span><span class="p">(</span>
                            <span class="n">preserve_expr</span><span class="o">=</span><span class="n">operand</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">expr_range_term</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_k</span><span class="p">])</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">expr_range_term</span><span class="o">.</span><span class="n">conversion_to_multiplication</span><span class="p">(</span>
                        <span class="n">preserve_expr</span><span class="o">=</span><span class="n">operand</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">associated</span><span class="p">(</span>
                        <span class="n">_k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="p">[</span><span class="n">replacement</span><span class="p">]))</span>

        <span class="c1"># eliminate zeros where possible</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">zero_eliminations</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="c1"># eliminated all but one term</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># perform cancelations where possible</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">cancelations</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="c1"># canceled all but one term</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="c1"># Check for any double-negations.</span>
        <span class="c1"># Normally, this would have been dealt with in the initial</span>
        <span class="c1"># reduction, but can emerge after disassociating a subtraction.</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_i</span><span class="p">],</span> <span class="n">Neg</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)):</span>
                <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">inner_expr</span><span class="o">.</span><span class="n">double_neg_simplification</span><span class="p">(</span>
                            <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># If all operands are irreducible, perform the evaluation.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>                
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_int</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
                    <span class="c1"># Evaluate the addition of two literal integers.</span>
                    <span class="n">evaluation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integer_binary_eval</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">evaluation</span>
                <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
                    <span class="c1"># Evaluate the addition of two literal rationals.</span>
                    <span class="n">evaluation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rational_binary_eval</span><span class="p">()</span>
                    <span class="k">return</span> <span class="n">evaluation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># In the future, handle adding irreducible</span>
                    <span class="c1"># complex numbers and/or irrationals as</span>
                    <span class="c1"># appropriate.</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Do a pairwise addition of irreducible terms.         </span>
                <span class="k">return</span> <span class="n">pairwise_evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">order_key_fn</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">order_key_fn</span>
        <span class="k">if</span> <span class="n">Add</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">combine_like_terms</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">must_evaluate</span><span class="p">):</span>
            <span class="c1"># Like terms are ones whose that are the same</span>
            <span class="c1"># apart from literal, rational coefficients.</span>
            <span class="n">likeness_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">term</span> <span class="p">:</span> <span class="p">(</span>
                    <span class="n">coefficient_and_remainder</span><span class="p">(</span><span class="n">term</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">Add</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">combine_like_denoms</span><span class="p">:</span>
                <span class="c1"># likeness_key_fn = lambda term : (</span>
                <span class="c1">#     Div(one, term.denominator) if isinstance(term, Div)</span>
                <span class="c1">#     else likeness_key_fn(term))</span>
                <span class="n">likeness_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">term</span> <span class="p">:</span> <span class="p">(</span>
                    <span class="n">Div</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">coefficient_and_remainder</span><span class="p">(</span><span class="n">term</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Sort and combine like operands.</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sorting_and_combining_like_operands</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span> <span class="n">order_key_fn</span><span class="o">=</span><span class="n">order_key_fn</span><span class="p">,</span> 
                    <span class="n">likeness_key_fn</span><span class="o">=</span><span class="n">likeness_key_fn</span><span class="p">,</span>
                    <span class="n">preserve_likeness_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># See if we should reorder the terms.</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sorting_operands</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">order_key_fn</span><span class="o">=</span><span class="n">order_key_fn</span><span class="p">,</span>
                                              <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Try starting over with a call to shallow_simplification</span>
            <span class="c1"># (an evaluation may already be known).</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">(</span>
                    <span class="n">must_evaluate</span><span class="o">=</span><span class="n">must_evaluate</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Addition evaluation only implemented for rationals: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">must_evaluate</span><span class="p">:</span>
            <span class="c1"># The simplification of the operands may not have</span>
            <span class="c1"># worked hard enough.  Let&#39;s work harder if we</span>
            <span class="c1"># must evaluate.</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
                    <span class="n">term</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
            <span class="c1"># Start over now that the terms are all evaluated to</span>
            <span class="c1"># irreductible values.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
    
    <span class="k">def</span> <span class="nf">quick_simplified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a simplified version of this Add expression</span>
<span class="sd">        without any proof.  In particular, negations are distributed</span>
<span class="sd">        nested additions are ungrouped, integers are extracted,</span>
<span class="sd">        added, and placed at the end, and cancelations are made on</span>
<span class="sd">        individual terms as well as expression ranges or portions of</span>
<span class="sd">        expression ranges.  We freely assume terms represent numbers</span>
<span class="sd">        and expression ranges are well-formed.</span>
<span class="sd">        This quick-n-dirty approach can be good</span>
<span class="sd">        enough for the purposes of displaying expressions involving</span>
<span class="sd">        expression ranges.  See also the quick_simplified_index </span>
<span class="sd">        function defined in number_operation.py.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">Neg</span>
        
        <span class="c1"># Extract any literal integers and expand nested sums.  </span>
        <span class="c1"># While we are at it, determing the extremal shifts at the </span>
        <span class="c1"># heads and tails of expression ranges.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># split into sign, abs_term pairs</span>
        <span class="n">int_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">remaining_terms</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">sign</span><span class="o">=</span><span class="mi">1</span>
        <span class="c1"># Map non-shifted head to latest shift of ExprRange terms:</span>
        <span class="n">latest_head_shift</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># (Lambda, index expr) -&gt; int</span>
        <span class="c1"># Map non-shiftted tail to earliest shift of ExprRange terms:</span>
        <span class="n">earliest_tail_shift</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># (Lambda, index expr) -&gt; int</span>
        <span class="n">all_abs_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">expandable_range</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Currently this doesn&#39;t expand ExprRange bodies that</span>
            <span class="c1"># are Add or Neg which would themselves be expanded.</span>
            <span class="c1"># This algorithm needs to be redesigned to handle such</span>
            <span class="c1"># fancy cases.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">or</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
            
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_terms</span><span class="p">):</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">remaining_terms</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">Neg</span><span class="p">:</span>
                <span class="c1"># Just an indication to switch the sign back.</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
                <span class="n">int_sum</span> <span class="o">+=</span> <span class="n">sign</span><span class="o">*</span><span class="n">term</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="c1"># Switch the sign and indicate to switch the sign</span>
                <span class="c1"># back later.</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>
                <span class="n">remaining_terms</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">Neg</span><span class="p">)</span>
                <span class="n">remaining_terms</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                <span class="n">remaining_terms</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">expandable_range</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
                <span class="n">start_base</span><span class="p">,</span> <span class="n">start_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span>
                        <span class="n">term</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">)</span>
                <span class="n">end_base</span><span class="p">,</span> <span class="n">end_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                <span class="n">lambda_map</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">lambda_map</span>
                <span class="n">latest_head_shift</span><span class="p">[(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">start_base</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">start_shift</span><span class="p">,</span> <span class="n">latest_head_shift</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">start_base</span><span class="p">),</span> <span class="n">start_shift</span><span class="p">))</span>
                <span class="n">earliest_tail_shift</span><span class="p">[(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">end_base</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">end_shift</span><span class="p">,</span> <span class="n">earliest_tail_shift</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">end_base</span><span class="p">),</span> <span class="n">end_shift</span><span class="p">))</span>
            <span class="n">all_abs_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">term</span><span class="p">))</span>
        <span class="n">term</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Extend the &quot;latest heads&quot; and &quot;earliest tails&quot; if there</span>
        <span class="c1"># are individual terms that match them so we can maximize</span>
        <span class="c1"># cancelations.</span>
        <span class="k">for</span> <span class="n">extremal_shifts</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="p">((</span><span class="n">latest_head_shift</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="p">(</span><span class="n">earliest_tail_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">extremal_shifts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">num</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                    <span class="n">_expr</span> <span class="o">=</span> <span class="n">lambda_map</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_expr</span> <span class="ow">in</span> <span class="n">all_abs_terms</span><span class="p">:</span>
                        <span class="n">shift</span> <span class="o">+=</span> <span class="n">step</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter</span> <span class="ow">not</span> <span class="ow">in</span>
                                <span class="n">free_vars</span><span class="p">(</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="p">)):</span>
                            <span class="c1"># avoid an infinite loop</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">extremal_shifts</span><span class="p">[(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">base</span><span class="p">)]</span> <span class="o">=</span> <span class="n">shift</span>
        
        <span class="c1"># Expand ExprRange heads and tails to their extremal shifts</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">latest_head_shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="n">terms</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span> <span class="ow">in</span> <span class="n">old_terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">expandable_range</span><span class="p">(</span><span class="n">abs_term</span><span class="p">):</span>
                    <span class="n">start_base</span><span class="p">,</span> <span class="n">start_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span><span class="n">abs_term</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">)</span>
                    <span class="n">end_base</span><span class="p">,</span> <span class="n">end_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span><span class="n">abs_term</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                    <span class="n">lambda_map</span> <span class="o">=</span> <span class="n">abs_term</span><span class="o">.</span><span class="n">lambda_map</span>
                    <span class="n">latest_start</span> <span class="o">=</span> <span class="n">latest_head_shift</span><span class="p">[(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">start_base</span><span class="p">)]</span>
                    <span class="n">earliest_end</span> <span class="o">=</span> <span class="n">earliest_tail_shift</span><span class="p">[(</span><span class="n">lambda_map</span><span class="p">,</span> <span class="n">end_base</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">start_base</span> <span class="o">==</span> <span class="n">end_base</span><span class="p">:</span>
                        <span class="c1"># For finite ranges, expand all elements.</span>
                        <span class="n">latest_start</span> <span class="o">=</span> <span class="n">end_shift</span><span class="o">+</span><span class="mi">1</span>
                    <span class="c1"># Peel off elements before the latest start.</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="n">start_shift</span>
                    <span class="k">while</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="n">latest_start</span><span class="p">:</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">start_base</span><span class="p">,</span> <span class="n">num</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                        <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">lambda_map</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">index</span><span class="p">)))</span>
                        <span class="n">shift</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">start_base</span> <span class="o">==</span> <span class="n">end_base</span> <span class="ow">and</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="n">end_shift</span><span class="p">:</span>
                        <span class="k">continue</span> <span class="c1"># already expanded all elements.</span>
                    <span class="n">start_index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">start_base</span><span class="p">,</span>
                                      <span class="n">num</span><span class="p">(</span><span class="n">latest_start</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                    <span class="n">end_index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">end_base</span><span class="p">,</span> 
                                    <span class="n">num</span><span class="p">(</span><span class="n">earliest_end</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">(</span><span class="n">abs_term</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> 
                                                  <span class="n">abs_term</span><span class="o">.</span><span class="n">body</span><span class="p">,</span>
                                                  <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)))</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="n">earliest_end</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># Peel off elements after the earliest end.</span>
                    <span class="k">while</span> <span class="n">shift</span> <span class="o">&lt;=</span> <span class="n">end_shift</span><span class="p">:</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">end_base</span><span class="p">,</span> <span class="n">num</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                        <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">lambda_map</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">index</span><span class="p">)))</span>
                        <span class="n">shift</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span><span class="p">))</span>
        
        <span class="c1"># Do cancelations of opposite terms.</span>
        <span class="c1"># Also check for clearly empty ExprRanges.</span>
        <span class="n">abs_term_to_neg_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">abs_term_to_pos_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cancelation_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abs_term</span> <span class="ow">in</span> <span class="n">abs_term_to_pos_idx</span><span class="p">:</span>
                    <span class="c1"># Neg term cancels with previous positive term.</span>
                    <span class="n">other_idx</span> <span class="o">=</span> <span class="n">abs_term_to_pos_idx</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">abs_term</span><span class="p">)</span>
                    <span class="n">cancelation_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">cancelation_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Store for possible cancelation ahead.</span>
                    <span class="n">abs_term_to_neg_idx</span><span class="p">[</span><span class="n">abs_term</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abs_term</span> <span class="ow">in</span> <span class="n">abs_term_to_neg_idx</span><span class="p">:</span>
                    <span class="c1"># Positive term cancels with previous Neg term.</span>
                    <span class="n">other_idx</span> <span class="o">=</span> <span class="n">abs_term_to_neg_idx</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">abs_term</span><span class="p">)</span>
                    <span class="n">cancelation_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">cancelation_indices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Store for possible cancelation ahead.</span>
                    <span class="n">abs_term_to_pos_idx</span><span class="p">[</span><span class="n">abs_term</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">term</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="k">if</span> 
                 <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cancelation_indices</span><span class="p">]</span>
        
        <span class="c1"># Re-extend heads and tails of ExprRanges that may have been</span>
        <span class="c1"># split apart, now that we&#39;ve had a chance to find cancelations.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">latest_head_shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Try to prepend heads going in reverse</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="n">terms</span>
            <span class="n">reversed_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">following_term</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">old_terms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">following_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sign</span><span class="o">==</span><span class="n">following_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
                            <span class="ow">and</span> <span class="n">expandable_range</span><span class="p">(</span><span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                        <span class="c1"># See if the current term prepends the head of</span>
                        <span class="c1"># the following range.</span>
                        <span class="n">start_base</span><span class="p">,</span> <span class="n">start_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span>
                                <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">)</span>
                        <span class="n">lambda_map</span> <span class="o">=</span> <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lambda_map</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">start_base</span><span class="p">,</span> 
                                    <span class="n">num</span><span class="p">(</span><span class="n">start_shift</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">abs_term</span> <span class="o">==</span> <span class="n">lambda_map</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                            <span class="c1"># Prepend the head.</span>
                            <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span>
                                    <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> 
                                    <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">,</span>
                                    <span class="n">index</span><span class="p">,</span> <span class="n">following_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="n">reversed_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">following_term</span><span class="p">)</span>
                <span class="n">following_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span><span class="p">]</span>
            <span class="n">reversed_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">following_term</span><span class="p">)</span> <span class="c1"># get the last one</span>
            
            <span class="c1"># Try to extend tails, reversing again.</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prev_term</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">reversed_terms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">prev_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sign</span><span class="o">==</span><span class="n">prev_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> 
                            <span class="n">expandable_range</span><span class="p">(</span><span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                        <span class="c1"># See if the current term extends the tail of</span>
                        <span class="c1"># the previous range.</span>
                        <span class="n">end_base</span><span class="p">,</span> <span class="n">end_shift</span> <span class="o">=</span> <span class="n">split_int_shift</span><span class="p">(</span>
                                <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                        <span class="n">lambda_map</span> <span class="o">=</span> <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lambda_map</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">end_base</span><span class="p">,</span> 
                                    <span class="n">num</span><span class="p">(</span><span class="n">end_shift</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">abs_term</span> <span class="o">==</span> <span class="n">lambda_map</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                            <span class="c1"># Extend the tail.</span>
                            <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span>
                                    <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span> <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">,</span>
                                    <span class="n">prev_term</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_term</span><span class="p">)</span>
                <span class="n">prev_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span><span class="p">]</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_term</span><span class="p">)</span> <span class="c1"># get the last one</span>
        
        <span class="c1"># Merge the sign and abs_term into each term.</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">abs_term</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sign</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_term</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">sign</span><span class="o">==-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abs_term</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="n">abs_term</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span><span class="n">abs_term</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">int_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">num</span><span class="p">(</span><span class="n">int_sum</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">terms</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">(</span><span class="n">int_sum</span><span class="p">)]))</span>

    <span class="k">def</span> <span class="nf">quick_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a simplification of this Add expression without any </span>
<span class="sd">        proof.  See Add.quick_simplified for more details.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">Equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">())</span>        

    <span class="k">def</span> <span class="nf">_integer_binary_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the sum of possibly negated single digit numbers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">num</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.numerals</span> <span class="k">import</span> <span class="n">DecimalSequence</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">assert</span> <span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_int</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">)</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">as_int</span><span class="p">(),</span> <span class="n">_b</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># evaluate -a-b via a+b</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="o">-</span><span class="n">_a</span><span class="p">,</span> <span class="o">-</span><span class="n">_b</span>
        <span class="k">if</span> <span class="n">_a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># evaluate -a+b via (a-b)+b or (b-a)+a</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="o">-</span><span class="n">_a</span>
            <span class="k">if</span> <span class="n">_a</span> <span class="o">&gt;</span> <span class="n">_b</span><span class="p">:</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">_a</span> <span class="o">-</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">_b</span> <span class="o">-</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_a</span>
        <span class="k">elif</span> <span class="n">_b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># evaluate a-b via (a-b)+b or (b-a)+a</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="o">-</span><span class="n">_b</span>
            <span class="k">if</span> <span class="n">_a</span> <span class="o">&gt;</span> <span class="n">_b</span><span class="p">:</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">_a</span> <span class="o">-</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">_b</span> <span class="o">-</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_a</span>
        <span class="k">assert</span> <span class="n">_a</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_b</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">term</span> <span class="ow">in</span> <span class="n">DIGITS</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">num</span><span class="p">(</span><span class="n">_b</span><span class="p">))):</span>
            <span class="c1"># multi-digit addition</span>
            <span class="k">return</span> <span class="n">DecimalSequence</span><span class="o">.</span><span class="n">add_eval</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">defaults</span><span class="o">.</span><span class="n">temporary</span><span class="p">()</span> <span class="k">as</span> <span class="n">temp_defaults</span><span class="p">:</span>
            <span class="c1"># We rely upon side-effect automation here.</span>
            <span class="n">temp_defaults</span><span class="o">.</span><span class="n">sideeffect_automation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># for single digit addition, import the theorem that provides</span>
            <span class="c1"># the evaluation</span>
            <span class="n">proveit</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">numerals</span><span class="o">.</span><span class="n">decimals</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span>
                    <span class="s1">&#39;add_</span><span class="si">%d</span><span class="s1">_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_rational_binary_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the sum of possibly literal rational numbers.</span>
<span class="sd">        The evaluation must be irreducible which means that the result</span>
<span class="sd">        (right hand side of the proven equation) must be an integer</span>
<span class="sd">        or a (possibly negated) fraction with no common divisors between</span>
<span class="sd">        the numerator and denominator other than 1.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">Div</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">is_numeric_rational</span><span class="p">,</span> 
                                     <span class="n">numeric_rational_ints</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">rational_pair_addition</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;_rational_binary_eval only applicable for binary addition &quot;</span>
                <span class="s2">&quot;of rationals&quot;</span><span class="p">)</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">num</span><span class="p">(</span><span class="n">_b</span><span class="p">),</span> <span class="n">num</span><span class="p">(</span><span class="n">_c</span><span class="p">),</span> <span class="n">num</span><span class="p">(</span><span class="n">_d</span><span class="p">)</span>
        <span class="c1"># Replace the irreducible forms with the original forms.</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="p">[</span><span class="n">Equals</span><span class="p">(</span><span class="n">Div</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">),</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">prove</span><span class="p">(),</span>
                        <span class="n">Equals</span><span class="p">(</span><span class="n">Div</span><span class="p">(</span><span class="n">_c</span><span class="p">,</span> <span class="n">_d</span><span class="p">),</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">prove</span><span class="p">()]</span>

        <span class="c1"># Combine the sum using</span>
        <span class="c1">#   (a/b) + (c/d) = (a*d + b*c)/(b*d)</span>
        <span class="c1"># Applying automatic simplifications should evaluate the</span>
        <span class="c1"># numerator and denominator and then reduce it to an</span>
        <span class="c1"># irreducible form.</span>
        <span class="k">return</span> <span class="n">rational_pair_addition</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span><span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span><span class="n">_d</span><span class="p">},</span> 
                <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">,</span>
                <span class="n">preserve_expr</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Add.subtraction_folding"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.subtraction_folding">[docs]</a>    <span class="k">def</span> <span class="nf">subtraction_folding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a negated term, term_idx or the first negated term if term_idx is None,</span>
<span class="sd">        deduce the equivalence between self and a Subtract form (with the specified</span>
<span class="sd">        negated term on the right of the subtraction).  Assumptions</span>
<span class="sd">        may be necessary to deduce operands being in the set of Complex numbers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.addition.subtraction.theorems</span> <span class="k">import</span> <span class="n">add_neg_as_subtract</span>
        <span class="k">if</span> <span class="n">term_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="n">term_idx</span> <span class="o">=</span> <span class="n">_k</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">term_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;No negated term, can&#39;t provide the subtraction folding.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">term_idx</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Specified term is not negated, can&#39;t provide the subtraction folding.&quot;</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">term_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">term_idx</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># put the negative term at the end</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">commute</span><span class="p">(</span><span class="n">term_idx</span><span class="p">,</span> <span class="n">term_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># group all of the other terms</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">add_neg_as_subtract</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="p">})</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def deduce_in_natural_pos_directly(self, assumptions=frozenset(), ruled_out_sets=frozenset(), dont_try_pos=False, dont_try_neg=False):</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        If all of the terms are in Natural and just one is positive, then the sum is positive.</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">        from proveit.numbers.number_sets import DeduceInNumberSetException, deduce_positive</span>
<span class="sd">        from . import add_nat_pos_closure</span>
<span class="sd">        from proveit.numbers import NaturalPos, num</span>
<span class="sd">        # first make sure all the terms are in Natural</span>
<span class="sd">        for _k, term in enumerate(self.operands):</span>
<span class="sd">            #try:</span>
<span class="sd">                # found one positive term to make the sum positive</span>
<span class="sd">            deduce_positive(term, assumptions)</span>
<span class="sd">            return add_nat_pos_closure.instantiate({i:num(_k), n:num(self.operands.num_entries()-_k-1), a:self.operands[:_k], b:term, c:self.operands[_k+1:]}, assumptions=assumptions)</span>
<span class="sd">            #except:</span>
<span class="sd">               # pass</span>
<span class="sd">        # need to have one of the elements positive for the sum to be positive</span>
<span class="sd">        raise DeduceInNumberSetException(self, NaturalPos, assumptions)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Add.deduce_in_number_set"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.deduce_in_number_set">[docs]</a>    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_in_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        given a number set, attempt to prove that the given expression is in that</span>
<span class="sd">        number set using the appropriate closure theorem</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.addition</span> <span class="k">as</span> <span class="nn">add_pkg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.addition.subtraction</span> <span class="k">import</span> <span class="p">(</span>
            <span class="n">subtract_nat_closure_bin</span><span class="p">,</span> <span class="n">sub_one_is_nat</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span>
                                     <span class="n">Less</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">,</span> <span class="n">greater_eq</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>
        
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ZeroSet</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_zero_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_zero_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Integer</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Real</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Complex</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_complex_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_complex_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
        
        <span class="c1"># Prove what we can in preparation.</span>
        <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="n">deduce_number_set</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>

        <span class="c1"># Handle special cases when all operands are in</span>
        <span class="c1"># the desired number set.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">InSet</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">number_set</span><span class="p">)</span><span class="o">.</span><span class="n">proven</span><span class="p">()</span> <span class="k">for</span>
               <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Natural</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_nat_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_nat_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_nat_pos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_nat_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">IntegerNeg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_neg_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">IntegerNonPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_nonpos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_nonpos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_pos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNeg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_neg_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonNeg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_nonneg_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_nonneg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_nonpos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_nonpos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_pos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNeg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_neg_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>                
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonNeg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_nonneg_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_nonneg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonPos</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_nonpos_closure_bin</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_nonpos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span><span class="n">_i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">})</span>

        <span class="c1"># Try special case where one term is positive and the</span>
        <span class="c1"># rest are non-negative.</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">NaturalPos</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">}:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">greater</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">_i</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">greater_eq</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="c1"># Not non-negative</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span> <span class="c1"># Forget it.</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_nat_pos_from_nonneg</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_pos_from_nonneg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_pos_from_nonneg</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">val</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">val</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="n">_j</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">temp_thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
        <span class="c1"># Try special case where one term is negative and the</span>
        <span class="c1"># rest are non-positive.</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">IntegerNeg</span><span class="p">,</span> <span class="n">RationalNeg</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">}:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">operand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">greater</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">_i</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">greater_eq</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="c1"># Not non-negative</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span> <span class="c1"># Forget it.</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_int_neg_from_nonpos</span>
                <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_rational_neg_from_nonpos</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp_thm</span> <span class="o">=</span> <span class="n">add_pkg</span><span class="o">.</span><span class="n">add_real_neg_from_nonpos</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">val</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">val</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
                <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="n">_j</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">temp_thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>

        <span class="c1"># Handle positive, negative, nonpos, nonneg, or nonzero</span>
        <span class="n">major_number_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">IntegerNonZero</span><span class="p">,</span> <span class="n">RationalNonZero</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">,</span>
                          <span class="n">ComplexNonZero</span><span class="p">}:</span>
            <span class="c1"># Prove it is not zero and prove it is in the corresponding</span>
            <span class="c1"># major number set (Integer, Rational, Real, or Complex)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_not_equal</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">to_major_number_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">IntegerNonZero</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                                   <span class="n">RationalNonZero</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                                   <span class="n">RealNonZero</span><span class="p">:</span><span class="n">Real</span><span class="p">,</span>
                                   <span class="n">ComplexNonZero</span><span class="p">:</span><span class="n">Complex</span><span class="p">}</span>
            <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">to_major_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">NaturalPos</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">}:</span>
            <span class="c1"># Prove it is positive and prove it is in the corresponding</span>
            <span class="c1"># major number set (Integer, Rational, Real)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_positive</span><span class="p">(</span><span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">to_major_number_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">NaturalPos</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                                   <span class="n">RationalPos</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                                   <span class="n">RealPos</span><span class="p">:</span><span class="n">Real</span><span class="p">}</span>
            <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">to_major_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">IntegerNeg</span><span class="p">,</span> <span class="n">RationalNeg</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">}:</span>
            <span class="c1"># Prove it is negative and prove it is in the corresponding</span>
            <span class="c1"># major number set (Integer, Rational, Real)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_negative</span><span class="p">(</span><span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">to_major_number_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">IntegerNeg</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                                   <span class="n">RationalNeg</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                                   <span class="n">RealNeg</span><span class="p">:</span><span class="n">Real</span><span class="p">}</span>
            <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">to_major_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">IntegerNonPos</span><span class="p">,</span> <span class="n">RationalNonPos</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">}:</span>
            <span class="c1"># Prove it is non-positive and prove it is in the </span>
            <span class="c1"># corresponding major number set (Integer, Rational, Real)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_non_positive</span><span class="p">(</span><span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">to_major_number_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">IntegerNonPos</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                                   <span class="n">RationalNonPos</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                                   <span class="n">RealNonPos</span><span class="p">:</span><span class="n">Real</span><span class="p">}</span>
            <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">to_major_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="p">{</span><span class="n">Natural</span><span class="p">,</span> <span class="n">RationalNonNeg</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">}:</span>
            <span class="c1"># Prove it is non-positive and prove it is in the </span>
            <span class="c1"># corresponding major number set (Integer, Rational, Real)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_non_negative</span><span class="p">(</span><span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">to_major_number_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">Natural</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                                   <span class="n">RationalNonNeg</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                                   <span class="n">RealNonNeg</span><span class="p">:</span><span class="n">Real</span><span class="p">}</span>
            <span class="n">major_number_set</span> <span class="o">=</span> <span class="n">to_major_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">major_number_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">major_number_set</span><span class="p">)</span>
            <span class="c1"># Now it should just go through.</span>
            <span class="k">return</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_as_last_resort</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;deduce_in_number_set&#39; on </span><span class="si">%s</span><span class="s2"> not implemented for the </span><span class="si">%s</span><span class="s2"> set&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">deduce_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove the sum is positive.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">greater</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">pos_difference</span>

        <span class="k">if</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">proven</span><span class="p">():</span>
            <span class="c1"># Already known (don&#39;t use readily_provable).</span>
            <span class="k">return</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="c1"># (a - b) with a &gt; b =&gt; (a - b) is positive</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="n">greater</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">pos_difference</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">try_deduce_number_set</span><span class="p">:</span>
            <span class="c1"># Try &#39;deduce_number_set&#39;.</span>
            <span class="n">deduce_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Last resort attempt</span>
        <span class="k">return</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove the sum is negative.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Less</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">neg_difference</span>

        <span class="k">if</span> <span class="n">Less</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">proven</span><span class="p">():</span>
            <span class="c1"># Already known (don&#39;t use readily_provable).</span>
            <span class="k">return</span> <span class="n">Less</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="c1"># (a - b) with a &lt; b =&gt; (a - b) is negative</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="n">Less</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">neg_difference</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">try_deduce_number_set</span><span class="p">:</span>
            <span class="c1"># Try &#39;deduce_number_set&#39;.</span>
            <span class="n">deduce_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Last resort attempt</span>
        <span class="k">return</span> <span class="n">Less</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deduce_non_positive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove the sum is non-positive.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">LessEq</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">nonpos_difference</span>

        <span class="k">if</span> <span class="n">LessEq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">proven</span><span class="p">():</span>
            <span class="c1"># Already known (don&#39;t use readily_provable).</span>
            <span class="k">return</span> <span class="n">LessEq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="c1"># (a - b) with a &lt;= b =&gt; (a - b) is non-positive</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="n">LessEq</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">nonpos_difference</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">try_deduce_number_set</span><span class="p">:</span>
            <span class="c1"># Try &#39;deduce_number_set&#39;.</span>
            <span class="n">deduce_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Last resort attempt</span>
        <span class="k">return</span> <span class="n">LessEq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deduce_non_negative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove the sum is non-negative.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">greater_eq</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">nonneg_difference</span>

        <span class="k">if</span> <span class="n">greater_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">proven</span><span class="p">():</span>
            <span class="c1"># Already known (don&#39;t use readily_provable).</span>
            <span class="k">return</span> <span class="n">greater_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="c1"># (a - b) with a &gt;= b =&gt; (a - b) is non-negative</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="n">greater_eq</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">nonneg_difference</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">try_deduce_number_set</span><span class="p">:</span>
            <span class="c1"># Try &#39;deduce_number_set&#39;.</span>
            <span class="n">deduce_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Last resort attempt</span>
        <span class="k">return</span> <span class="n">greater_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the most restrictive number set we can readily</span>
<span class="sd">        prove contains the evaluation of this number operation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">Neg</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span> <span class="n">greater_eq</span><span class="p">,</span>
                                     <span class="n">Less</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">)</span>
        <span class="n">nonzero_to_full_number_set</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">IntegerNonZero</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span>
                <span class="n">RationalNonZero</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span>
                <span class="n">RealNonZero</span><span class="p">:</span><span class="n">Real</span><span class="p">,</span>
                <span class="n">ComplexNonZero</span><span class="p">:</span><span class="n">Complex</span><span class="p">}</span>
        <span class="n">operands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">if</span> <span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ZeroSet</span> <span class="c1"># [+]() = 0</span>
        <span class="n">list_of_operand_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># find a minimal std number set for operand</span>
        <span class="n">any_positive</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">any_negative</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
            <span class="n">operand_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">operand_ns</span><span class="p">):</span>
                <span class="n">any_positive</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">operand_ns</span><span class="p">):</span>
                <span class="n">any_negative</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">list_of_operand_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand_ns</span><span class="p">)</span>
        <span class="c1"># Find the number set that </span>
        <span class="n">number_set</span> <span class="o">=</span> <span class="n">union_number_set</span><span class="p">(</span><span class="o">*</span><span class="n">list_of_operand_sets</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="n">nonzero_to_full_number_set</span><span class="p">:</span>
            <span class="c1"># Adding non-zero operands provides no guarantee that the</span>
            <span class="c1"># result will be non-zero (unlike adding positives,</span>
            <span class="c1"># negatives, nonpositives, or nonnegatives).</span>
            <span class="n">number_set</span> <span class="o">=</span> <span class="n">nonzero_to_full_number_set</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>

        <span class="n">restriction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">number_set</span><span class="p">):</span>
            <span class="n">restriction</span> <span class="o">=</span> <span class="n">pos_number_set</span> <span class="c1"># must be positive</span>
        <span class="k">elif</span> <span class="n">RealNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">number_set</span><span class="p">):</span>
            <span class="n">restriction</span> <span class="o">=</span> <span class="n">neg_number_set</span> <span class="c1"># must be negative</span>
        <span class="k">elif</span> <span class="n">RealNonNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">number_set</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">any_positive</span><span class="p">:</span>
                <span class="n">restriction</span> <span class="o">=</span> <span class="n">pos_number_set</span> <span class="c1"># must be positive</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">restriction</span> <span class="o">=</span> <span class="n">nonneg_number_set</span> <span class="c1"># must be non-negative</span>
        <span class="k">elif</span> <span class="n">RealNonPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">number_set</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">any_negative</span><span class="p">:</span>
                <span class="n">restriction</span> <span class="o">=</span> <span class="n">neg_number_set</span> <span class="c1"># must be negative</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">restriction</span> <span class="o">=</span> <span class="n">nonpos_number_set</span> <span class="c1"># must be non-positive</span>

        <span class="k">if</span> <span class="n">restriction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">pos_number_set</span><span class="p">,</span> <span class="n">neg_number_set</span><span class="p">):</span>
            <span class="c1"># Check for the special case of a - b where we know</span>
            <span class="c1"># a &gt; b, a &lt; b, a  b, a  b, or a  b</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
                <span class="k">if</span> <span class="n">greater</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">restriction</span> <span class="o">=</span> <span class="n">pos_number_set</span> <span class="c1"># positive</span>
                <span class="k">elif</span> <span class="n">greater_eq</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">restriction</span> <span class="o">=</span> <span class="n">nonneg_number_set</span> <span class="c1"># non-negative</span>
                <span class="k">elif</span> <span class="n">Less</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">restriction</span> <span class="o">=</span> <span class="n">neg_number_set</span> <span class="c1"># negative</span>
                <span class="k">elif</span> <span class="n">LessEq</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">restriction</span> <span class="o">=</span> <span class="n">nonpos_number_set</span> <span class="c1"># non-positive</span>
                <span class="k">elif</span> <span class="n">NotEquals</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">restriction</span> <span class="o">=</span> <span class="n">nonzero_number_set</span> <span class="c1"># non-zero</span>
        
        <span class="c1"># Use the positive, negative, non-negative, non-positive, or</span>
        <span class="c1"># non-zero restriction.</span>
        <span class="k">if</span> <span class="n">restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">restriction</span><span class="p">[</span><span class="n">number_set</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">number_set</span>

    <span class="c1"># IS THIS NECESSARY?</span>
<div class="viewcode-block" id="Add.deduce_difference_in_natural"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.deduce_difference_in_natural">[docs]</a>    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">deduce_difference_in_natural</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.number_sets.integers</span> <span class="k">import</span> <span class="n">difference_is_nat</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;deduce_difference_in_natural only applicable &quot;</span>
                             <span class="s2">&quot;when there are two terms, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;deduce_difference_in_natural only applicable &quot;</span>
                             <span class="s2">&quot;for a subtraction, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">thm</span> <span class="o">=</span> <span class="n">difference_is_nat</span>
        <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="p">})</span></div>

    <span class="c1"># IS THIS NECESSARY?</span>
<div class="viewcode-block" id="Add.deduce_difference_in_natural_pos"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.deduce_difference_in_natural_pos">[docs]</a>    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">deduce_difference_in_natural_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.number_sets.integers</span> <span class="k">import</span> <span class="n">difference_is_nat_pos</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;deduce_difference_in_natural_pos only applicable &quot;</span>
                <span class="s2">&quot;when there are two terms, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;deduce_difference_in_natural_pos only applicable &quot;</span>
                <span class="s2">&quot;for a subtraction, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="bp">self</span><span class="p">)</span>
        <span class="n">thm</span> <span class="o">=</span> <span class="n">difference_is_nat_pos</span>
        <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_term</span><span class="p">,</span> <span class="n">also_return_num</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the starting index of the_term, which may be a single </span>
<span class="sd">        operand, a list of consecutive operands, or a Add expression </span>
<span class="sd">        that represents the sum of the list of consecutive operands.</span>
<span class="sd">        If also_return_num is True, return a tuple of the index and </span>
<span class="sd">        number of operands for the_term.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_term</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">the_term</span> <span class="o">=</span> <span class="n">the_term</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">the_term</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">the_term</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
            <span class="c1"># multiple operands in the_term</span>
            <span class="n">first_term</span> <span class="o">=</span> <span class="n">the_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_term</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">first_term</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">entries</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">the_term</span><span class="p">):</span>
                        <span class="k">break</span>  <span class="c1"># found it all!</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Term is absent!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">the_term</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Term is absent!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">also_return_num</span> <span class="k">else</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">readily_factorable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True iff &#39;factor&#39; is factorable from &#39;self&#39; in an</span>
<span class="sd">        obvious manner.  For this Add, it is readily factorable if</span>
<span class="sd">        it is readily factorable from all terms.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">readily_factorable</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">factor</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Add.factorization"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.factorization">[docs]</a>    <span class="nd">@auto_equality_prover</span><span class="p">(</span><span class="s1">&#39;factorized&#39;</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">the_factors</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> 
                      <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Factor out the factor(s) from this sum, pulling it either to </span>
<span class="sd">        the &quot;left&quot; or &quot;right&quot;.</span>
<span class="sd">        If group_factors is True, the factors are grouped</span>
<span class="sd">        together as a sub-product.</span>
<span class="sd">        In the Add case, the remainder will always be grouped (we</span>
<span class="sd">        have &#39;group_remainder&#39; as a parameter just for recursion</span>
<span class="sd">        compatibility).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.multiplication</span> <span class="k">import</span> <span class="n">distribute_through_sum</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">one</span><span class="p">,</span> <span class="n">Mult</span>
        <span class="k">if</span> <span class="n">pull</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;pull&#39; must be &#39;left&#39; or &#39;right&#39;&quot;</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># for convenience updating our equation</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="c1"># If &#39;the_factors&#39; is not an Expression, assume it is</span>
            <span class="c1"># an iterable and make it a Mult.</span>
            <span class="n">the_factors</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">the_factors</span><span class="p">)</span>
        <span class="c1"># factor the_factor from each term</span>
        <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()):</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">term</span> <span class="o">==</span> <span class="n">the_factors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">one_elimination</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span><span class="o">.</span><span class="n">one_elimination</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="s1">&#39;factorization&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Factor, </span><span class="si">%s</span><span class="s2">, is not present in the term at &quot;</span>
                        <span class="s2">&quot;index </span><span class="si">%d</span><span class="s2"> of </span><span class="si">%s</span><span class="s2">!&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">the_factors</span><span class="p">,</span> <span class="n">_i</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
                <span class="n">term_factorization</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                    <span class="n">the_factors</span><span class="p">,</span> <span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="n">group_factors</span><span class="p">,</span>
                    <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_factorization</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Expecting right hand side of each factorization &quot;</span>
                        <span class="s2">&quot;to be a product. Instead obtained: </span><span class="si">{0}</span><span class="s2"> for term &quot;</span>
                        <span class="s2">&quot;number </span><span class="si">{1}</span><span class="s2"> (0-based index).&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">term_factorization</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">_i</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                    <span class="c1"># the grouped remainder on the right</span>
                    <span class="n">_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term_factorization</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># the grouped remainder on the left</span>
                    <span class="n">_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term_factorization</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># substitute in the factorized term</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">term_factorization</span><span class="o">.</span><span class="n">substitution</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">_i</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">group_factors</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_factors</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="n">factor_sub</span> <span class="o">=</span> <span class="n">the_factors</span><span class="o">.</span><span class="n">operands</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factor_sub</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">(</span><span class="n">the_factors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pull</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">factor_sub</span>
            <span class="n">_c</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">()</span>
            <span class="n">_c</span> <span class="o">=</span> <span class="n">factor_sub</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="n">ExprTuple</span><span class="p">(</span><span class="o">*</span><span class="n">_b</span><span class="p">)</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_k</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">distribution</span> <span class="o">=</span> <span class="n">distribute_through_sum</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_k</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">},</span> 
            <span class="n">preserve_expr</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">distribution</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span></div>
    
    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;combined_terms&#39;</span><span class="p">,</span> <span class="s1">&#39;combine_terms&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">combining_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Combine terms, adding their literal, rational coefficients.</span>
<span class="sd">        Alias for `combining_operands`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">one</span><span class="p">,</span> <span class="n">Div</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.multiplication.mult</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">coefficient_and_remainder</span><span class="p">)</span>
        <span class="c1"># Obtain the common term &quot;remainder&quot; (sans coefficient),</span>
        <span class="c1"># raising a ValueError if the terms are not all like terms.</span>
        <span class="n">likeness_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">term</span> <span class="p">:</span> <span class="p">(</span>
                <span class="n">coefficient_and_remainder</span><span class="p">(</span><span class="n">term</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">common_likeness_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likeness_key_fn</span><span class="o">=</span><span class="n">likeness_key_fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="ow">not</span><span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">Div</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_e</span>
            <span class="c1"># testing new denominator def to accommodate ExprRange?</span>
            <span class="c1"># denominator = common_likeness_key(</span>
            <span class="c1">#         self, likeness_key_fn = lambda term: term.denominator)</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="n">common_likeness_key</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">likeness_key_fn</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">denominator</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span>
                                <span class="k">else</span> <span class="n">term</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">denominator</span><span class="p">))</span>
            <span class="c1"># the following handles both a set of fracs and an</span>
            <span class="c1"># ExprRange of fracs and any combination of the two</span>
            <span class="n">numerator_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">map_elements</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">numerator</span><span class="p">)</span>
            <span class="c1"># create our desired combination of like fractions</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">Div</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">numerator_terms</span><span class="p">),</span> <span class="n">denominator</span><span class="p">)</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">auto_simplify</span><span class="p">:</span>
                <span class="n">combined_simp</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">combined_simp</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">combined_simp</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
                    <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined_simp</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span>
                    <span class="n">derive_reversed</span><span class="p">(</span><span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
            <span class="c1"># Factor out the common part from the coefficients.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

        <span class="c1"># All of the operands are rational, literals.</span>
        <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">auto_simplify</span><span class="p">:</span>
            <span class="c1"># Simplify if auto-simplification is on.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_via_reflexivity</span><span class="p">()</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;combined_operands&#39;</span><span class="p">,</span> <span class="s1">&#39;combine_operands&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">combining_operands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Combine terms, adding their literal, rational coeffiicents.</span>
<span class="sd">        Alias for `combining_terms`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combining_terms</span><span class="p">()</span> 

<div class="viewcode-block" id="Add.commutation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.commutation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;commuted&#39;</span><span class="p">,</span> <span class="s1">&#39;commute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">commutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">final_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                    <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal </span>
<span class="sd">        to a form in which the operand</span>
<span class="sd">        at index init_idx has been moved to final_idx.</span>
<span class="sd">        For example, (a + b + ... + y + z) = (a + ... + y + b + z)</span>
<span class="sd">        via init_idx = 1 and final_idx = -2.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">commutation</span><span class="p">,</span> <span class="n">leftward_commutation</span><span class="p">,</span> <span class="n">rightward_commutation</span>
        <span class="k">return</span> <span class="n">apply_commutation_thm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">commutation</span><span class="p">,</span>
            <span class="n">leftward_commutation</span><span class="p">,</span> <span class="n">rightward_commutation</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Add.group_commutation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.group_commutation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;group_commuted&#39;</span><span class="p">,</span> <span class="s1">&#39;group_commute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">group_commutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
                          <span class="n">disassociate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal</span>
<span class="sd">        to a form in which the operands at indices </span>
<span class="sd">        [init_idx, init_idx+length) have been moved to </span>
<span class="sd">        [final_idx. final_idx+length).</span>
<span class="sd">        It will do this by performing association first.  </span>
<span class="sd">        If disassocate is True, it will be disassociated afterwards.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">group_commutation</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">disassociate</span><span class="o">=</span><span class="n">disassociate</span><span class="p">)</span></div>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;moved&#39;</span><span class="p">,</span> <span class="s1">&#39;move&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">permutation_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">final_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal </span>
<span class="sd">        to a form in which the operand</span>
<span class="sd">        at index init_idx has been moved to final_idx.</span>
<span class="sd">        For example, (a + b + ... + y + z) = (a + ... + y + b + z)</span>
<span class="sd">        via init_idx = 1 and final_idx = -2.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">commutation</span><span class="p">(</span><span class="n">init_idx</span><span class="p">,</span> <span class="n">final_idx</span><span class="p">)</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;permuted&#39;</span><span class="p">,</span> <span class="s1">&#39;permute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cycles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this Add expression is equal to an Add in which</span>
<span class="sd">        the terms at indices 0, 1, , n-1 have been reordered as</span>
<span class="sd">        specified EITHER by the new_order list OR by the cycles list</span>
<span class="sd">        parameter. For example,</span>
<span class="sd">            (a+b+c+d).permutation_general(new_order=[0, 2, 3, 1])</span>
<span class="sd">        and</span>
<span class="sd">            (a+b+c+d).permutation_general(cycles=[(1, 2, 3)])</span>
<span class="sd">        would both return  (a+b+c+d) = (a+c+d+b).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">generic_permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">,</span> <span class="n">cycles</span><span class="p">)</span>

<div class="viewcode-block" id="Add.association"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.association">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;associated&#39;</span><span class="p">,</span> <span class="s1">&#39;associate&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">association</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal </span>
<span class="sd">        to a form in which operands in the</span>
<span class="sd">        range [start_idx, start_idx+length) are grouped together.</span>
<span class="sd">        For example, (a + b + ... + y + z) = </span>
<span class="sd">            (a + b ... + (l + ... + m) + ... + y + z)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">association</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">apply_association_thm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">association</span><span class="p">)</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # DON&#39;T WORRY ABOUT RESETTING THE STYLE FOR THE MOMENT.</span>
<span class="sd">        # set the subraction style as appropriate given what we started with:</span>
<span class="sd">        subtraction_positions = self.subtraction_positions()</span>
<span class="sd">        eq.inner_expr().lhs.with_subtraction_at(*subtraction_positions)</span>
<span class="sd">        beg_positions = [p for p in subtraction_positions if p &lt; start_idx]</span>
<span class="sd">        inner_positions = [p-start_idx for p in subtraction_positions if start_idx &lt;= p &lt; start_idx+length]</span>
<span class="sd">        end_positions = [p-length for p in subtraction_positions if p &gt; start_idx+length]</span>
<span class="sd">        eq.inner_expr().rhs.operands[start_idx].with_subtraction_at(*inner_positions)</span>
<span class="sd">        eq.inner_expr().rhs.operands[start_idx].with_subtraction_at(*(beg_positions + end_positions))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">eq</span></div>

<div class="viewcode-block" id="Add.disassociation"><a class="viewcode-back" href="../../../../api/proveit.numbers.Add.html#proveit.numbers.Add.disassociation">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;disassociated&#39;</span><span class="p">,</span> <span class="s1">&#39;disassociate&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">disassociation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given numerical operands, deduce that this expression is equal </span>
<span class="sd">        to a form in which the operand</span>
<span class="sd">        at index idx is no longer grouped together.</span>
<span class="sd">        For example, (a + b ... + (l + ... + m) + ... + y+ z) </span>
<span class="sd">            = (a + b + ... + y + z)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.core_expr_types</span> <span class="k">import</span> <span class="n">Len</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">disassociation</span>
        <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">subtraction_disassociation</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Neg</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Add</span><span class="p">)):</span>
            <span class="n">subtraction_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span><span class="o">.</span><span class="n">operands</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="n">subtraction_terms</span>
            <span class="n">_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">Len</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span><span class="o">.</span><span class="n">computed</span><span class="p">()</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">Len</span><span class="p">(</span><span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">computed</span><span class="p">()</span>
            <span class="n">_k</span> <span class="o">=</span> <span class="n">Len</span><span class="p">(</span><span class="n">_c</span><span class="p">)</span><span class="o">.</span><span class="n">computed</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">subtraction_disassociation</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_k</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">apply_disassociation_thm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">disassociation</span><span class="p">)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # DON&#39;T WORRY ABOUT RESETTING THE STYLE FOR THE MOMENT.</span>
<span class="sd">        # set the subraction style as appropriate given what we started with:</span>
<span class="sd">        subtraction_positions = self.subtraction_positions()</span>
<span class="sd">        inner_positions = self.operand[idx].subtraction_positions()</span>
<span class="sd">        inner_num_operands = len(self.operand[idx])</span>
<span class="sd">        eq.inner_expr().lhs.operands[idx].with_subtraction_at(*inner_positions)</span>
<span class="sd">        eq.inner_expr().lhs.with_subtraction_at(*subtraction_positions)</span>
<span class="sd">        new_positions = [p for p in subtraction_positions if p &lt; idx]</span>
<span class="sd">        new_positions.extend([p+idx for p in inner_positions])</span>
<span class="sd">        new_positions.extend([p+inner_num_operands for p in subtraction_positions if p &gt; idx])</span>
<span class="sd">        eq.inner_expr().rhs.with_subtraction_at(*new_positions)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">eq</span></div>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_via_operand_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand_relation</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Alias for bound_via_term_bound.</span>
<span class="sd">        Also see NumberOperation.deduce_bound.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_via_term_bound</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_via_term_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_relation</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce a bound of this sum via the bound on</span>
<span class="sd">        one of its terms.  For example</span>
<span class="sd">            a + b + c + d &lt; a + z + c + d   given   b &lt; z.</span>

<span class="sd">        Also see NumberOperation.deduce_bound.            </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">NumberOrderingRelation</span><span class="p">,</span> <span class="n">Less</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_relation</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="n">term_relation</span> <span class="o">=</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_relation</span><span class="p">,</span> <span class="n">NumberOrderingRelation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;term_relation&#39; expected to be a number &quot;</span>
                            <span class="s2">&quot;relation (&lt;, &gt;, , or )&quot;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">also_return_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;term_relation&#39; expected to be a relation &quot;</span>
                            <span class="s2">&quot;for one of the terms; neither term of </span><span class="si">%s</span><span class="s2"> &quot;</span>
                            <span class="s2">&quot;appears in the </span><span class="si">%s</span><span class="s2"> relation.&quot;</span>
                            <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_relation</span><span class="p">))</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">num</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
            <span class="c1"># Handle the binary cases.</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">relation</span> <span class="o">=</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">right_add_both_sides</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">relation</span> <span class="o">=</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">left_add_both_sides</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">relation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                <span class="c1"># We can use the strong bound.</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">strong_bound_via_term_bound</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">strong_bound_via_term_bound</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We may only use the weak bound.</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">weak_bound_via_term_bound</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">weak_bound_via_term_bound</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_j</span> <span class="o">=</span> <span class="n">_b</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">normal_lhs</span>
            <span class="n">_y</span> <span class="o">=</span> <span class="n">term_relation</span><span class="o">.</span><span class="n">normal_rhs</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y</span><span class="p">}))</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>            
        <span class="n">relation</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">if</span> <span class="n">relation</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">relation</span> <span class="o">=</span> <span class="n">relation</span><span class="o">.</span><span class="n">with_direction_reversed</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">relation</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">relation</span>    

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_by_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">,</span> <span class="n">use_weak_bound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this sum is bound by the given term (or term at</span>
<span class="sd">        the given index).</span>
<span class="sd">        </span>
<span class="sd">        For example,</span>
<span class="sd">        a + b + c + d  b provided that a  0, c  0, and d  0.</span>
<span class="sd">        </span>
<span class="sd">        To use this method, we must know that the</span>
<span class="sd">        other terms are all in RealPos, RealNeg, RealNonNeg, or</span>
<span class="sd">        RealNonPos and will call</span>
<span class="sd">        deduce_weak_upper_bound_by_term,</span>
<span class="sd">        deduce_strong_upper_bound_by_term,</span>
<span class="sd">        deduce_weak_lower_bound_by_term,</span>
<span class="sd">        deduce_strong_lower_bound_by_term</span>
<span class="sd">        accordingly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span> <span class="n">RealNonPos</span>
        <span class="n">relevant_number_sets</span> <span class="o">=</span> <span class="p">{</span><span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">term_entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_k</span> <span class="o">==</span> <span class="n">term_or_idx</span> <span class="ow">or</span> <span class="n">term_entry</span> <span class="o">==</span> <span class="n">term_or_idx</span><span class="p">:</span> 
                <span class="c1"># skip the term doing the bounding.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">number_set</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">relevant_number_sets</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_entry</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="n">in_number_set</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">ExprRange</span><span class="p">(</span>
                            <span class="n">term_entry</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span>
                            <span class="n">InSet</span><span class="p">(</span><span class="n">term_entry</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">number_set</span><span class="p">),</span>
                            <span class="n">term_entry</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span> 
                            <span class="n">term_entry</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">in_number_set</span> <span class="o">=</span> <span class="n">InSet</span><span class="p">(</span><span class="n">term_entry</span><span class="p">,</span> <span class="n">number_set</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_number_set</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="n">relevant_number_sets</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">number_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">relevant_number_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsatisfiedPrerequisites</span><span class="p">(</span>
                    <span class="s2">&quot;In order to use Add.bound_by_term, the &quot;</span>
                    <span class="s2">&quot;&#39;other&#39; terms must all be known to be contained &quot;</span>
                    <span class="s2">&quot;in RealPos, RealNeg, RealNonNeg, RealNonPos&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_weak_bound</span><span class="p">:</span>
            <span class="c1"># If a strong bound is applicable, use that.</span>
            <span class="k">if</span> <span class="n">RealPos</span> <span class="ow">in</span> <span class="n">relevant_number_sets</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduce_strong_lower_bound_by_term</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">RealNeg</span> <span class="ow">in</span> <span class="n">relevant_number_sets</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduce_strong_upper_bound_by_term</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">RealNonNeg</span> <span class="ow">in</span> <span class="n">relevant_number_sets</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduce_weak_lower_bound_by_term</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">RealNonPos</span> <span class="ow">in</span> <span class="n">relevant_number_sets</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduce_weak_upper_bound_by_term</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_weak_lower_bound_by_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this sum is greater than or equal to the term at the</span>
<span class="sd">        given index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">term_as_weak_lower_bound</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deduce_specific_bound_by_term</span><span class="p">(</span>
                <span class="n">term_as_weak_lower_bound</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_weak_upper_bound_by_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this sum is less than or equal to the term at the</span>
<span class="sd">        given index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">term_as_weak_upper_bound</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deduce_specific_bound_by_term</span><span class="p">(</span>
                <span class="n">term_as_weak_upper_bound</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_strong_lower_bound_by_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this sum is greater than the term at the</span>
<span class="sd">        given index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">term_as_strong_lower_bound</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deduce_specific_bound_by_term</span><span class="p">(</span>
                <span class="n">term_as_strong_lower_bound</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">)</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_strong_upper_bound_by_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Deduce that this sum is less than the term at the</span>
<span class="sd">        given index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">term_as_strong_upper_bound</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deduce_specific_bound_by_term</span><span class="p">(</span>
                <span class="n">term_as_strong_upper_bound</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deduce_specific_bound_by_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thm</span><span class="p">,</span> <span class="n">term_or_idx</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Helper method for </span>
<span class="sd">        deduce_weak_lower_bound_by_term,</span>
<span class="sd">        deduce_weak_upper_bound_by_term, </span>
<span class="sd">        deduce_strong_lower_bound_by_term, and </span>
<span class="sd">        deduce_strong_lower_bound_by_term.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;term_or_idx&#39; must be one of the terms of </span><span class="si">%s</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;or an index for one of the terms.&quot;</span><span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_or_idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;term_or_idx&#39; must be an Expression or int&quot;</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">term_or_idx</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="n">_j</span> <span class="o">=</span> <span class="n">_c</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">_i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_j</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>        

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">try_deduce_number_set</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove that self is not equal to other.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Neg</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">.subtraction</span> <span class="k">import</span> <span class="n">nonzero_difference_if_different</span>
                    <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">operand</span>
                    <span class="k">if</span> <span class="n">NotEquals</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                        <span class="c1"># If we know (or can readily prove) that</span>
                        <span class="c1"># _a != _b then we can prove _a - _b != 0.</span>
                        <span class="k">return</span> <span class="n">nonzero_difference_if_different</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                                <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="n">_b</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">try_deduce_number_set</span><span class="p">:</span>
                <span class="c1"># Try deducing the number set.</span>
                <span class="n">number_set</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ComplexNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">number_set</span><span class="p">):</span>
                    <span class="n">deduce_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
            <span class="c1"># Readily provable.</span>
            <span class="k">return</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        <span class="c1"># If it isn&#39;t a special case treated here, just use</span>
        <span class="c1"># conclude-as-folded.</span>
        <span class="k">return</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_as_folded</span><span class="p">()</span></div>

<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../../api/proveit.numbers.subtract.html#proveit.numbers.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the a-b expression (which is internally a+(-b)).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter_or_parameters</span><span class="p">,</span>
                      <span class="n">Neg</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                      <span class="n">b</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">get_styles</span><span class="p">())</span>
        <span class="c1"># The default style will use subtractions where appropriate.</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Neg</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="dist_subtract"><a class="viewcode-back" href="../../../../api/proveit.numbers.dist_subtract.html#proveit.numbers.dist_subtract">[docs]</a><span class="k">def</span> <span class="nf">dist_subtract</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the distributed a-b expression.  That is, if a or b are</span>
<span class="sd">    Add expressions, combine all of the terms into a single Add</span>
<span class="sd">    expression (not nested).  For example, with</span>
<span class="sd">    a:x-y, b:c+d-e+g, it would return x-y-c-d+e-g.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
        <span class="n">bterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">term</span><span class="o">.</span><span class="n">operand</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="k">else</span> <span class="n">Neg</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">terms</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
        <span class="n">bterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">ExprRange</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">parameter_or_parameters</span><span class="p">,</span>
                            <span class="n">Neg</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">lambda_map</span><span class="o">.</span><span class="n">body</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                            <span class="n">b</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">get_styles</span><span class="p">())]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Neg</span><span class="p">(</span><span class="n">b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
        <span class="n">aterms</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">terms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="c1"># The default style will use subtractions where appropriate.</span>
    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">aterms</span> <span class="o">+</span> <span class="n">bterms</span><span class="p">))</span></div>


<div class="viewcode-block" id="dist_add"><a class="viewcode-back" href="../../../../api/proveit.numbers.dist_add.html#proveit.numbers.dist_add">[docs]</a><span class="k">def</span> <span class="nf">dist_add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the distributed sum of expression.  That is, if any of</span>
<span class="sd">    the terms are Add expressions, expand them.  For example,</span>
<span class="sd">    dist_add(x-y, c+d-e+g) would return x-y+c+d-e+g.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">expanded_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">expanded_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expanded_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">expanded_terms</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">split_int_shift</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    If the expression contains an additive integer shift term,</span>
<span class="sd">    return the remaining terms and the shift independently as a pair.</span>
<span class="sd">    Otherwise, return the expression paired with a zero shift.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Neg</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="c1"># wrap in an Add so we can do quick_simplified</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">quick_simplified</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">shift</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> 
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ExprRange</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shift</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">expr</span><span class="o">.</span><span class="n">terms</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">entries</span><span class="p">),</span> <span class="n">shift</span>
    <span class="k">if</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">zero</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expression.html">as_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expressions.html">as_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_equality_prover.html">auto_equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_prover.html">auto_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_relation_prover.html">auto_relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.composite_expression.html">composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.equality_prover.html">equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.expression_depth.html">expression_depth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_var_ranges.html">free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.generate_inner_expressions.html">generate_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.horiz_var_array.html">horiz_var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced.html">maybe_fenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_latex.html">maybe_fenced_latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_string.html">maybe_fenced_string</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.prover.html">prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.relation_prover.html">relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_default_or_dummy_var.html">safe_default_or_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_var.html">safe_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_vars.html">safe_dummy_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_index.html">simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_indices.html">simplified_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.single_or_composite_expression.html">single_or_composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.total_ordering.html">total_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_literals.html">used_literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_array.html">var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_range.html">var_range</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.vert_var_array.html">vert_var_array</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composition.html">Composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ConditionalSet.html">ConditionalSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Deduction.html">Deduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExprGenerator.html">InnerExprGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Judgment.html">Judgment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterMaskingError.html">ParameterMaskingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterRelabelingError.html">ParameterRelabelingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.SimplificationDirectives.html">SimplificationDirectives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryException.html">TheoryException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryPackage.html">TheoryPackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnsatisfiedPrerequisites.html">UnsatisfiedPrerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnusableProof.html">UnusableProof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Variable.html">Variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.VertExprArray.html">VertExprArray</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.core_expr_types.Len.html">Len</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.conclude_via_implication.html">conclude_via_implication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.deduce_equal_or_not.html">deduce_equal_or_not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_falsehood.html">evaluate_falsehood</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_truth.html">evaluate_truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluation_or_simplification.html">evaluation_or_simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.in_bool.html">in_bool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.is_irreducible_value.html">is_irreducible_value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_proper_superset.html">not_proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_superset_eq.html">not_superset_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.proper_superset.html">proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.superset_eq.html">superset_eq</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Bijections.html">Bijections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.BooleanSet.html">BooleanSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartExp.html">CartExp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartProd.html">CartProd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassMembership.html">ClassMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassNonmembership.html">ClassNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.FalseLiteral.html">FalseLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InClass.html">InClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Injections.html">Injections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IntersectAll.html">IntersectAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InvImage.html">InvImage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInClass.html">NotInClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotProperSubset.html">NotProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.PowerSet.html">PowerSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ProperSubset.html">ProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetEquiv.html">SetEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetMembership.html">SetMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNonmembership.html">SetNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNotEquiv.html">SetNotEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.StrictSubset.html">StrictSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetProper.html">SubsetProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Surjections.html">Surjections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.TrueLiteral.html">TrueLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Union.html">Union</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UnionAll.html">UnionAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UniqueExists.html">UniqueExists</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.complex_polar_coordinates.html">complex_polar_coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_fraction.html">compose_fraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_product.html">compose_product</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_as_mon_dec_func.html">deduce_as_mon_dec_func</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_in_number_set.html">deduce_in_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_not_equal_numeric_rationals.html">deduce_not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_number_set.html">deduce_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.exp2pi_i.html">exp2pi_i</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater.html">greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater_eq.html">greater_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_int.html">is_numeric_int</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_natural.html">is_numeric_natural</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_rational.html">is_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_ints.html">less_eq_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_rationals.html">less_eq_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_ints.html">less_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_rationals.html">less_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.negated.html">negated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.not_equal_numeric_rationals.html">not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.number_ordering.html">number_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.numeric_rational_ints.html">numeric_rational_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.quick_simplified_index.html">quick_simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_factorable.html">readily_factorable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_provable_number_set.html">readily_provable_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.remove_common_factors.html">remove_common_factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.simplified_numeric_rational.html">simplified_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrd.html">sqrd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.standard_number_set.html">standard_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.subtract.html">subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.union_number_set.html">union_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.unit_length_complex_polar_angle.html">unit_length_complex_polar_angle</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.BinarySequence.html">BinarySequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Conjugate.html">Conjugate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DividesProper.html">DividesProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.KroneckerDelta.html">KroneckerDelta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Log.html">Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.MonDecFuncs.html">MonDecFuncs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOperation.html">NumberOperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOrderingRelation.html">NumberOrderingRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>