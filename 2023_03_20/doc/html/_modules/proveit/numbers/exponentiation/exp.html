
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>proveit.numbers.exponentiation.exp &#8212; Prove-It 0.3 documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
<header>These are archival webpages, generated on 2023-03-20 by <a href="https://github.com/sandialabs/Prove-It">Prove-It</a> Beta Version 0.3, licensed under the GNU Public Licence by Sandia Corporation.  See <a href="http://pyproveit.org">pyproveit.org</a> for the lastest version.</header>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for proveit.numbers.exponentiation.exp</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="p">(</span><span class="n">defaults</span><span class="p">,</span> <span class="n">equality_prover</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">,</span>
                     <span class="n">Function</span><span class="p">,</span>
                     <span class="n">InnerExpr</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">maybe_fenced_string</span><span class="p">,</span>
                     <span class="n">SimplificationDirectives</span><span class="p">,</span>
                     <span class="n">ProofFailure</span><span class="p">,</span> <span class="n">prover</span><span class="p">,</span> <span class="n">relation_prover</span><span class="p">,</span> <span class="n">StyleOptions</span><span class="p">,</span>
                     <span class="n">UnsatisfiedPrerequisites</span><span class="p">,</span> <span class="n">USE_DEFAULTS</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">proveit</span>
<span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">theta</span>
<span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">Equals</span><span class="p">,</span> <span class="n">InSet</span><span class="p">,</span> <span class="n">SetMembership</span><span class="p">,</span> <span class="n">NotEquals</span>
<span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">greater_eq</span>
<span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">NumberOperation</span><span class="p">,</span> <span class="n">deduce_number_set</span><span class="p">,</span>
                             <span class="n">readily_provable_number_set</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">proveit.numbers.number_sets</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ZeroSet</span><span class="p">,</span> <span class="n">Natural</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">,</span>
    <span class="n">Integer</span><span class="p">,</span> <span class="n">IntegerNonZero</span><span class="p">,</span> <span class="n">IntegerNeg</span><span class="p">,</span> <span class="n">IntegerNonPos</span><span class="p">,</span>
    <span class="n">Rational</span><span class="p">,</span> <span class="n">RationalNonZero</span><span class="p">,</span> <span class="n">RationalPos</span><span class="p">,</span> <span class="n">RationalNeg</span><span class="p">,</span> <span class="n">RationalNonNeg</span><span class="p">,</span>
    <span class="n">RationalNonPos</span><span class="p">,</span>
    <span class="n">Real</span><span class="p">,</span> <span class="n">RealNonZero</span><span class="p">,</span> <span class="n">RealNeg</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">,</span> <span class="n">RealNonPos</span><span class="p">,</span>
    <span class="n">Complex</span><span class="p">,</span> <span class="n">ComplexNonZero</span><span class="p">)</span>

<div class="viewcode-block" id="Exp"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp">[docs]</a><span class="k">class</span> <span class="nc">Exp</span><span class="p">(</span><span class="n">NumberOperation</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    An Expression class to represent an exponentiation.  Derive from</span>
<span class="sd">    Function since infix notation should not be a style option.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># operator of the Exp operation.</span>
    <span class="n">_operator_</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">string_format</span><span class="o">=</span><span class="s1">&#39;Exp&#39;</span><span class="p">,</span> <span class="n">theory</span><span class="o">=</span><span class="vm">__file__</span><span class="p">)</span>

    <span class="n">_simplification_directives_</span> <span class="o">=</span> <span class="n">SimplificationDirectives</span><span class="p">(</span>
            <span class="n">reduce_double_exponent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">distribute_exponent</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">factor_numeric_rational</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Raise base to exponent power.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span>
        <span class="n">NumberOperation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Exp</span><span class="o">.</span><span class="n">_operator_</span><span class="p">,</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">),</span>
                                 <span class="n">styles</span><span class="o">=</span><span class="n">styles</span><span class="p">)</span>

<div class="viewcode-block" id="Exp.remake_constructor"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.remake_constructor">[docs]</a>    <span class="k">def</span> <span class="nf">remake_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="s1">&#39;raised&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;radical&#39;</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s1">&#39;sqrt&#39;</span>
        <span class="k">return</span> <span class="n">Function</span><span class="o">.</span><span class="n">remake_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.remake_arguments"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.remake_arguments">[docs]</a>    <span class="k">def</span> <span class="nf">remake_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Yield the argument values or (name, value) pairs</span>
<span class="sd">        that could be used to recreate the Operation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="s1">&#39;raised&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;radical&#39;</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span></div>

<div class="viewcode-block" id="Exp.style_options"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.style_options">[docs]</a>    <span class="k">def</span> <span class="nf">style_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the StyleOptions object for this Exp.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">StyleOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">numerator</span> <span class="o">==</span> <span class="n">one</span><span class="p">):</span>
            <span class="n">options</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&#39;raised&#39;: exponent as a superscript; &quot;</span>
                             <span class="s2">&quot;&#39;radical&#39;: using a radical sign&quot;</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="s1">&#39;radical&#39;</span><span class="p">,</span>
                <span class="n">related_methods</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;with_radical&#39;</span><span class="p">,</span> <span class="s1">&#39;without_radical&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">options</span></div>

<div class="viewcode-block" id="Exp.string"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.string">[docs]</a>    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.latex"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.latex">[docs]</a>    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.formatted"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.formatted">[docs]</a>    <span class="k">def</span> <span class="nf">formatted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># begin building the inner_str</span>
        <span class="n">inner_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span>
            <span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_fence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if self.get_style(&#39;exponent&#39;, &#39;TEST&#39;) == &#39;TEST&#39; and self.exponent == frac(one, two):</span>
        <span class="c1">#     self.with_radical()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="s1">&#39;raised&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;raised&#39;</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">inner_str</span>
                <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;^{&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="o">+</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;radical&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">format_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                    <span class="n">inner_str</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">r</span><span class="s1">&#39;sqrt(&#39;</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="n">force_fence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">format_type</span> <span class="o">==</span> <span class="s1">&#39;latex&#39;</span><span class="p">:</span>
                    <span class="n">inner_str</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">r</span><span class="s1">&#39;\sqrt{&#39;</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="n">force_fence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">format_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                    <span class="n">inner_str</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">denominator</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39; radical(&#39;</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">force_fence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">format_type</span> <span class="o">==</span> <span class="s1">&#39;latex&#39;</span><span class="p">:</span>
                    <span class="n">inner_str</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">r</span><span class="s1">&#39;\sqrt[\leftroot{-3}\uproot</span><span class="si">{3}</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">denominator</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]{&#39;</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">formatted</span><span class="p">(</span><span class="n">format_type</span><span class="p">,</span> <span class="n">fence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">force_fence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s1">&#39;}&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown radical type, exponentiating to the power &quot;</span>
                    <span class="s2">&quot;of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="c1"># only fence if force_fence=True (nested exponents is an</span>
        <span class="c1"># example of when fencing must be forced)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;force_fence&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;force_fence&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maybe_fenced_string</span><span class="p">(</span><span class="n">inner_str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.membership_object"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.membership_object">[docs]</a>    <span class="k">def</span> <span class="nf">membership_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ExpSetMembership</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.with_radical"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.with_radical">[docs]</a>    <span class="k">def</span> <span class="nf">with_radical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_styles</span><span class="p">(</span><span class="n">exponent</span><span class="o">=</span><span class="s1">&#39;radical&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.without_radical"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.without_radical">[docs]</a>    <span class="k">def</span> <span class="nf">without_radical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_styles</span><span class="p">(</span><span class="n">exponent</span><span class="o">=</span><span class="s1">&#39;raised&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_build_canonical_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The canonical form of an Exp will address:</span>
<span class="sd">            x^0 = 1</span>
<span class="sd">            x^1 = x</span>
<span class="sd">            (x*y*z)^a = x^a * y^a * z^a</span>
<span class="sd">            (x^a)^b = x^(a*b) if a and b are numeric rationals.</span>
<span class="sd">            x^{2n} = (-x)^{2n} if 2n is a numeric even number (2, 4, ..)</span>
<span class="sd">        Also, raising a literal rational to an integer power equates</span>
<span class="sd">        to a irreducible rational.</span>
<span class="sd">        Some of these equalities require the base of the exponent</span>
<span class="sd">        to be nonzero, but these should work as long as the expression</span>
<span class="sd">        is not a garbage expression.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> 
                                     <span class="n">is_numeric_rational</span><span class="p">,</span> <span class="n">is_numeric_int</span><span class="p">,</span>
                                     <span class="n">numeric_rational_ints</span><span class="p">,</span>
                                     <span class="n">simplified_numeric_rational</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span> <span class="c1"># x^0 = 1</span>
        <span class="k">elif</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span> <span class="c1"># x^1 = x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="c1"># (x*y*z)^a = x^a * y^a * z^a</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">ExprRange</span><span class="p">):</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">ExprRange</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">parameter</span><span class="p">,</span>
                                       <span class="n">Exp</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">exponent</span><span class="p">),</span>
                                       <span class="n">factor</span><span class="o">.</span><span class="n">true_start_index</span><span class="p">,</span>
                                       <span class="n">factor</span><span class="o">.</span><span class="n">true_end_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">factors</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="c1"># return Mult(*[Exp(factor, exponent) for factor </span>
            <span class="c1">#               in base.factors])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
            <span class="c1"># (x^a)^b = x^(a*b)</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span>
            <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">):</span>
            <span class="c1"># Raising a numeric rational to an integer power.</span>
            <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="c1"># A negative power will flip the numerator</span>
                <span class="c1"># and denominator.</span>
                <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">denom</span><span class="p">,</span> <span class="n">numer</span>
                <span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="o">.</span><span class="n">operand</span>
            <span class="n">numer</span> <span class="o">=</span> <span class="n">numer</span><span class="o">**</span><span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">())</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">denom</span><span class="o">**</span><span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">simplified_numeric_rational</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">and</span> 
                <span class="nb">any</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_term</span><span class="p">)</span> <span class="k">for</span> <span class="n">_term</span> 
                    <span class="ow">in</span> <span class="n">exponent</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)):</span>
            <span class="c1"># Raising a numeric rational to a power with a numeric</span>
            <span class="c1"># rational term; factor out the numeric rational via</span>
            <span class="c1"># a^{x + b} = a^b * a^x</span>
            <span class="n">numeric_exp_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_term</span> <span class="k">for</span> <span class="n">_term</span> <span class="ow">in</span> <span class="n">exponent</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span>
                                 <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_term</span><span class="p">)]</span>
            <span class="n">nonnumeric_exp_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_term</span> <span class="k">for</span> <span class="n">_term</span> <span class="ow">in</span> <span class="n">exponent</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_term</span><span class="p">)]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">numeric_exp_terms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">Mult</span><span class="p">(</span><span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">numeric_exp_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">(),</span>
                        <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">nonnumeric_exp_terms</span><span class="p">))</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># x^{2n} = (-x)^{2n}, so choose one of these forms </span>
            <span class="c1"># deterministically.</span>
            <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Abs</span>
            <span class="c1"># reuse code dealing with |x| = |-x|:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">Abs</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span><span class="o">.</span><span class="n">operand</span>
        <span class="k">if</span> <span class="n">base</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="ow">or</span> <span class="n">exponent</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">:</span>
            <span class="c1"># Use the canonical forms of the base and exponent.</span>
            <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_deduce_canonically_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove equality of Exp asssuming they have the same canonical</span>
<span class="sd">        form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">is_numeric_int</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">exponent</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">and</span> 
                <span class="n">is_numeric_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">Neg</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span> <span class="o">==</span>
                        <span class="n">rhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">())):</span>
            <span class="c1"># This is a x^{2n} = (-x)^{2n} case.</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">even_pow_is_even_fn_rev</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Equals</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">two</span><span class="p">,</span> <span class="n">_n</span><span class="p">),</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">())</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Equals</span><span class="p">(</span><span class="n">Neg</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">rhs</span><span class="o">.</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">even_pow_is_even_fn_rev</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">_x</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">_n</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">,</span>
                    <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Prove equality using standard techniques.</span>
        <span class="k">return</span> <span class="n">NumberOperation</span><span class="o">.</span><span class="n">_deduce_canonically_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>        
        
    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;shallow_simplified&#39;</span><span class="p">,</span> <span class="s1">&#39;shallow_simplify&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shallow_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">must_evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a proven simplification equation for this Exp</span>
<span class="sd">        expression assuming the operands have been simplified.</span>

<span class="sd">        Handles the following simplifications:</span>
<span class="sd">            a^0 = 1 for any complex a</span>
<span class="sd">            0^x = 0 for any positive x</span>
<span class="sd">            1^x = 1 for any complex x</span>
<span class="sd">            a^(Log(a, x)) = x for RealPos a and x, a != 1.</span>
<span class="sd">            x^n = x*x*...*x = ? for a natural n and irreducible x.</span>
<span class="sd">            (-x)^2 = x^2 or any even, numeric power</span>
<span class="sd">        </span>
<span class="sd">        Additionally may do the following depending upon simplification</span>
<span class="sd">        directives:</span>
<span class="sd">            * If reduce_double_exponent is True:</span>
<span class="sd">                (x^y)^z = x^{y*z}</span>
<span class="sd">            * If distribute_exponent is True:</span>
<span class="sd">                (a*b*c)^f = a^f * b^f * c^f</span>
<span class="sd">                (a/b)^f = (a^f / b^f)</span>
<span class="sd">            * If factor_numeric_rational is True:</span>
<span class="sd">                a^{x+b} = a^b a^x if a and b are numeric rationals.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.relation</span> <span class="k">import</span> <span class="n">TransRelUpdater</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">is_irreducible_value</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span>
                                     <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">is_numeric_rational</span><span class="p">,</span>
                                     <span class="n">numeric_rational_ints</span><span class="p">,</span>
                                     <span class="n">Log</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Abs</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span><span class="n">exp_zero_eq_one</span><span class="p">,</span> <span class="n">exponentiated_zero</span><span class="p">,</span>
                       <span class="n">exponentiated_one</span><span class="p">,</span> <span class="n">exp_nat_pos_expansion</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irreducible_value</span><span class="p">():</span>
            <span class="c1"># already irreducible</span>
            <span class="k">return</span> <span class="n">Equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_via_reflexivity</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">must_evaluate</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span> <span class="k">for</span>
                       <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_irreducible_value</span><span class="p">(</span><span class="n">operand</span><span class="p">):</span>
                        <span class="c1"># The simplification of the operands may not have</span>
                        <span class="c1"># worked hard enough.  Let&#39;s work harder if we</span>
                        <span class="c1"># must evaluate.</span>
                        <span class="n">operand</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
        
        <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">numeric_rational_ints</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_zero_eq_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">base</span><span class="p">})</span>  <span class="c1"># =1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="c1"># Will fail if the exponent is not positive, but this</span>
            <span class="c1"># is the only sensible thing to try.</span>
            <span class="k">return</span> <span class="n">exponentiated_zero</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>  <span class="c1"># =0</span>
        <span class="k">elif</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_of_one_reduction</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exponentiated_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>  <span class="c1"># =1</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">numerator</span> <span class="o">==</span> <span class="n">one</span> <span class="ow">and</span>
                <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">denominator</span> <span class="o">==</span> <span class="n">exponent</span> <span class="ow">and</span>
                <span class="n">greater_eq</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">InSet</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">())):</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">nth_power_of_nth_root</span>
            <span class="k">return</span> <span class="n">nth_power_of_nth_root</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Div</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">exponent</span><span class="o">.</span><span class="n">numerator</span> <span class="o">==</span> <span class="n">one</span> <span class="ow">and</span>
                <span class="n">exponent</span><span class="o">.</span><span class="n">denominator</span> <span class="o">==</span> <span class="n">base</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">two</span> <span class="ow">or</span>
                 <span class="p">(</span><span class="n">greater_eq</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">())</span> <span class="ow">and</span>
                 <span class="n">InSet</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()))):</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">nth_root_of_nth_power</span><span class="p">,</span> <span class="n">sqrt_of_square</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">exponent</span>
            <span class="n">_x</span> <span class="o">=</span>  <span class="n">base</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">_n</span> <span class="o">==</span> <span class="n">two</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sqrt_of_square</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">nth_root_of_nth_power</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">_x</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># exponentiate a rational to a positive integer</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">exp_nat_pos_expansion</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">base</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">exponent</span><span class="p">},</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="c1"># We should come up with a better way of reducing</span>
            <span class="c1"># ExprRanges representing repetitions:</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">_n</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently only implemented for 1-9&quot;</span><span class="p">)</span>
            <span class="n">repetition_thm</span> <span class="o">=</span> <span class="n">proveit</span><span class="o">.</span><span class="n">numbers</span><span class="o">.</span><span class="n">numerals</span><span class="o">.</span><span class="n">decimals</span> \
                <span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="s1">&#39;reduce_</span><span class="si">%s</span><span class="s1">_repeats&#39;</span> <span class="o">%</span> <span class="n">_n</span><span class="p">)</span>
            <span class="n">rep_reduction</span> <span class="o">=</span> <span class="n">repetition_thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">base</span><span class="p">})</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">substitution</span><span class="p">(</span>
                    <span class="n">rep_reduction</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">evaluation</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span>
                  <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># exponentiate a rational to a negative integer</span>
            <span class="c1"># _a and _b are the numerator and denominator as ints.</span>
            <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">neg_power_as_div</span><span class="p">,</span> <span class="n">neg_power_of_quotient</span><span class="p">)</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="o">-</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">_b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">neg_power_as_div</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="n">num</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="n">_n</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">neg_power_of_quotient</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="n">num</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span> <span class="n">b</span><span class="p">:</span><span class="n">num</span><span class="p">(</span><span class="n">_b</span><span class="p">),</span> <span class="n">n</span><span class="p">:</span><span class="n">_n</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Log</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">base</span> <span class="o">==</span> <span class="n">exponent</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="c1"># base_ns  = base.deduce_number_set()</span>
            <span class="c1"># antilog_ns = exponent.antilog.deduce_number_set()</span>
            <span class="k">if</span> <span class="n">InSet</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">InSet</span><span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">antilog</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span>
                    <span class="ow">and</span> <span class="n">NotEquals</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_of_log_reduction</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">two</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Abs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">InSet</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span><span class="n">square_abs_rational_simp</span><span class="p">,</span>
                                     <span class="n">square_abs_real_simp</span><span class="p">)</span>
            <span class="c1"># |a|^2 = a if a is real</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="c1"># for convenience updating our equation:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">base_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> 
                                                  <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
            <span class="n">rational_base</span> <span class="o">=</span> <span class="n">Rational</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span>
            <span class="n">real_base</span> <span class="o">=</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">rational_base</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">square_abs_rational_simp</span>
            <span class="k">elif</span> <span class="n">real_base</span><span class="p">:</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">square_abs_real_simp</span>
            <span class="k">if</span> <span class="n">thm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">simp</span> <span class="o">=</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">operand</span><span class="p">})</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">simp</span><span class="p">)</span>
                <span class="c1"># A further simplification may be possible after</span>
                <span class="c1"># eliminating the absolute value.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">simplification</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Neg</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># (-x)^2 = x^2, (-x)^4 = x^4, etc.</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">even_pow_is_even_fn</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Equals</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="n">two</span><span class="p">,</span> <span class="n">_n</span><span class="p">),</span> <span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">even_pow_is_even_fn</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">base</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="n">_n</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Exp</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">reduce_double_exponent</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">InSet</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span> 
                 <span class="n">InSet</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                 <span class="n">NotEquals</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span>
                         <span class="n">InSet</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">())):</span>
                <span class="c1"># (a^b)^c = a^{b*c}</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">double_exponent_reduction</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Exp</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">distribute_exponent</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Mult</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Div</span><span class="p">)):</span>
            <span class="c1"># Distribute the exponent as directed.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span><span class="n">auto_simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">Exp</span><span class="o">.</span><span class="n">_simplification_directives_</span><span class="o">.</span><span class="n">factor_numeric_rational</span><span class="p">:</span>
            <span class="c1"># a^{x+b} = a^b a^x if a and b are numeric rationals</span>
            <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Add</span><span class="p">)</span> <span class="ow">and</span> 
                    <span class="nb">any</span><span class="p">(</span><span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_term</span><span class="p">)</span> <span class="k">for</span> <span class="n">_term</span> 
                        <span class="ow">in</span> <span class="n">exponent</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span><span class="p">)):</span>
                <span class="c1"># The base and one of the exponent terms is a numeric</span>
                <span class="c1"># rational.</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="c1"># Pull numeric rationals to the front of the exponent</span>
                <span class="c1"># terms.</span>
                <span class="k">with</span> <span class="n">Add</span><span class="o">.</span><span class="n">temporary_simplification_directives</span><span class="p">()</span> <span class="k">as</span> <span class="n">_tmp_drvs</span><span class="p">:</span>
                    <span class="n">_tmp_drvs</span><span class="o">.</span><span class="n">ungroup</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">_tmp_drvs</span><span class="o">.</span><span class="n">combine_like_terms</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">_tmp_drvs</span><span class="o">.</span><span class="n">order_key_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">term</span> <span class="p">:</span> <span class="p">(</span>
                            <span class="mi">0</span> <span class="k">if</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span>
                            <span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">())</span>
                <span class="c1"># Associate into two terms: numeric rationals and</span>
                <span class="c1"># everything else.</span>
                <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">entries</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_numeric_rational</span><span class="p">(</span><span class="n">_term</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="n">_terms</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">terms</span>
                <span class="n">_num_terms</span> <span class="o">=</span> <span class="n">_terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_k</span> <span class="o">&lt;</span> <span class="n">_num_terms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">expr</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">num_entries</span><span class="p">():</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                                        <span class="n">_k</span><span class="p">,</span> <span class="n">_num_terms</span><span class="o">-</span><span class="n">_k</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">_k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                                <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                                        <span class="mi">0</span><span class="p">,</span> <span class="n">_k</span><span class="p">,</span> <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">exponent_separation</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">simplification</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
                    
        <span class="k">return</span> <span class="n">Equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_via_reflexivity</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">is_irreducible_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This needs work, but we know that sqrt(2) is irreducible as</span>
<span class="sd">        a special case.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">two</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span> <span class="c1"># TODO: handle more cases.</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;power_of_one_reduced&#39;</span><span class="p">,</span> <span class="s1">&#39;power_of_one_reduce&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">power_of_one_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">complex_x_to_first_power_is_x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;power_of_one_reduction&#39; only applicable when &quot;</span>
                             <span class="s2">&quot;the exponent is 1, not </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">complex_x_to_first_power_is_x</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;power_of_log_reduced&#39;</span><span class="p">,</span> <span class="s1">&#39;power_of_log_reduce&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">power_of_log_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Log</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">exponent_log_with_same_base</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Log</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Exp.power_of_log() method only applicable when &quot;</span>
                    <span class="s2">&quot;the exponent is a Log with base matching the Exp &quot;</span>
                    <span class="s2">&quot;base. Instead we have Exp base </span><span class="si">{0}</span><span class="s2"> and Exp &quot;</span>
                    <span class="s2">&quot;exponent </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">exponent_log_with_same_base</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">antilog</span><span class="p">})</span>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove that self is equal to other.</span>
<span class="sd">        Handles r exp(i theta) = r. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">complex_polar_coordinates</span>
        <span class="n">reductions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_r</span><span class="p">,</span> <span class="n">_theta</span> <span class="o">=</span> <span class="n">complex_polar_coordinates</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">reductions</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">_r</span> <span class="o">=</span> <span class="n">_theta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_r</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># r exp(i theta) = r if theta/(2 pi) is an integer</span>
                <span class="k">if</span> <span class="n">_r</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">unit_complex_polar_num_eq_one</span>
                    <span class="k">return</span> <span class="n">unit_complex_polar_num_eq_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="n">_theta</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">complex_polar_num_eq_one</span>
                    <span class="k">return</span> <span class="n">complex_polar_num_eq_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">_r</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">_theta</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;deduce_equal case not handled: </span><span class="si">%s</span><span class="s2"> ≠ </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">readily_not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True if we can readily prove &#39;self&#39; is not &#39;other&#39;.</span>
<span class="sd">        Handles a^b ≠ 0 and exp(i theta) ≠ 1. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="c1"># a^b ≠ 0 or a ≠ 0 </span>
            <span class="k">return</span> <span class="n">NotEquals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">one</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
                <span class="c1"># exp(i theta) ≠ 1 if and only if exp(-i theta) ≠ 1,</span>
                <span class="c1"># so the sign doesn&#39;t matter.</span>
                <span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent</span><span class="o">.</span><span class="n">operand</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span> <span class="c1"># exp(i) ≠ 1</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
                <span class="n">exponent_factors</span> <span class="o">=</span> <span class="n">exponent</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">entries</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exponent_factors</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">i_idx</span> <span class="o">=</span> <span class="n">exponent_factors</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">theta_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">_idx</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exponent_factors</span><span class="p">)</span>
                                 <span class="k">if</span> <span class="n">_idx</span> <span class="o">!=</span> <span class="n">i_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">InSet</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">theta_factors</span><span class="p">),</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">True</span>                
        <span class="k">return</span> <span class="kc">False</span>            

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove that self is not equal to other.</span>
<span class="sd">        Handles a^b ≠ 0 and exp(i theta) ≠ 1. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span><span class="p">,</span> <span class="n">complex_polar_coordinates</span>
        <span class="c1">#from . import </span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduce_not_zero</span><span class="p">()</span>
        <span class="n">reductions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_r</span><span class="p">,</span> <span class="n">_theta</span> <span class="o">=</span> <span class="n">complex_polar_coordinates</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">reductions</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">_r</span> <span class="o">=</span> <span class="n">_theta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_r</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># r exp(i theta) ≠ r if theta/(2 pi) is not an integer</span>
                <span class="k">if</span> <span class="n">_r</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">unit_complex_polar_num_neq_one</span>
                    <span class="k">return</span> <span class="n">unit_complex_polar_num_neq_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="n">_theta</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">complex_polar_num_neq_one</span>
                    <span class="k">return</span> <span class="n">complex_polar_num_neq_one</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">_r</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">_theta</span><span class="p">},</span> <span class="n">replacements</span><span class="o">=</span><span class="n">reductions</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;deduce_not_equal case not handled: </span><span class="si">%s</span><span class="s2"> ≠ </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

<div class="viewcode-block" id="Exp.deduce_not_zero"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.deduce_not_zero">[docs]</a>    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_not_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Prove that this exponential is not zero given that</span>
<span class="sd">        the base is not zero.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">readily_provable_number_set</span><span class="p">,</span> <span class="n">RationalPos</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">exp_rational_non_zero__not_zero</span><span class="p">,</span> <span class="n">exp_not_eq_zero</span>
        <span class="n">base_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="n">exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">exp_not_eq_zero</span><span class="o">.</span><span class="n">is_usable</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">RationalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">RationalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">))):</span>
            <span class="c1"># Special case where the base and exponent are RationalPos.</span>
            <span class="k">return</span> <span class="n">exp_rational_non_zero__not_zero</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">exp_not_eq_zero</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span></div>

<div class="viewcode-block" id="Exp.expansion"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.expansion">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;expanded&#39;</span><span class="p">,</span> <span class="s1">&#39;expand&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From self of the form x^n return x^n = x(x)...(x).</span>
<span class="sd">        For example, Exp(x, two).expansion(assumptions)</span>
<span class="sd">        should return: assumptions |- (x^2) =  (x)(x). Currently only</span>
<span class="sd">        implemented explicitly for powers of n=2 and n=3.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">square_expansion</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">square_expansion</span><span class="o">.</span><span class="n">instance_param</span>
            <span class="k">return</span> <span class="n">square_expansion</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">_x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">cube_expansion</span>
            <span class="n">_x</span> <span class="o">=</span> <span class="n">cube_expansion</span><span class="o">.</span><span class="n">instance_param</span>
            <span class="k">return</span> <span class="n">cube_expansion</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">_x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Exp.expansion() implemented only for exponential &quot;</span>
                         <span class="s2">&quot;powers n=2 or n=3, but received an exponential &quot;</span>
                         <span class="s2">&quot;power of </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exponent</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">readily_factorable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True iff &#39;factor&#39; is factorable from &#39;self&#39; in an</span>
<span class="sd">        obvious manner.  For this Exp, a^b is readily factorable</span>
<span class="sd">        from c^d if a is factorable from c and either</span>
<span class="sd">        d &gt;= b &gt;= 0 or d &lt;= b &lt;= 0 is readily provable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">,</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">Neg</span><span class="p">,</span>
                                     <span class="n">readily_factorable</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">factor</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="c1"># Convert a/b to a*b^{-1}</span>
            <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="o">==</span><span class="n">one</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">Neg</span><span class="p">(</span><span class="n">one</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> 
                              <span class="n">Exp</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">denominator</span><span class="p">,</span> <span class="n">Neg</span><span class="p">(</span><span class="n">one</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
            <span class="n">factor_base</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">factor_base</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ineq_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">greater_eq</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ineq_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> 
                                 <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">ineq_type</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> 
                                      <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                        <span class="c1"># a^b factorable from c^d because a is factorable</span>
                        <span class="c1"># from c and d &gt;= b.</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">greater_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="c1"># a factorable from c^d because a is factorable</span>
                <span class="c1"># from c and d &gt;= 1.</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;factorized&#39;</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                      <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">group_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the proven factorization (equality with the factored</span>
<span class="sd">        form) from pulling the factor(s) from this exponentiation to </span>
<span class="sd">        the &quot;left&quot; or &quot;right&quot;.  Examples:</span>
<span class="sd">            (a*b)^c = (a^c)*(b^c), pulling a^c to the left or</span>
<span class="sd">                                   pulling b^c to the right</span>
<span class="sd">            (a*b)^c = (a^d)*(a^{d-c})(b^c) pulling a^d to the left</span>
<span class="sd">            (a*b)^c = a*((a^{c-1})*(b^c)) pulling a to the left with</span>
<span class="sd">                                          group_remainder=True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">Expression</span><span class="p">,</span> <span class="n">TransRelUpdater</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">subtract</span><span class="p">,</span> <span class="n">readily_factorable</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">exp_factored_int</span><span class="p">,</span> <span class="n">exp_factored_real</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># A convenience for iteratively updating our equation,</span>
        <span class="c1"># beginning with self = self</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">TransRelUpdater</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="c1"># trivial or base case</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>  <span class="c1"># self = self</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="n">reduction</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">reduction_to_mult</span><span class="p">()</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">reduction</span><span class="o">.</span><span class="n">rhs</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduction</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">()]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                    <span class="n">factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="n">group_factors</span><span class="p">,</span>
                    <span class="n">group_remainder</span><span class="o">=</span><span class="n">group_remainder</span><span class="p">,</span>
                    <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">)</span>

        <span class="n">base_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="n">exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span> 
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting &#39;factor&#39; to be an Expression&quot;</span><span class="p">)</span>            
        
        
        <span class="k">with</span> <span class="n">Mult</span><span class="o">.</span><span class="n">temporary_simplification_directives</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp_directives</span><span class="p">:</span>
            <span class="c1"># Prevent exponents from re-combining as we factor them out.</span>
            <span class="n">tmp_directives</span><span class="o">.</span><span class="n">combine_numeric_rational_exponents</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">tmp_directives</span><span class="o">.</span><span class="n">combine_all_exponents</span><span class="o">=</span><span class="kc">False</span>
            
            <span class="n">replacements</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">factor</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                    <span class="c1"># Special case factoring a out of a^1 as a^1 = 1.</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_of_one_reduction</span><span class="p">()</span>
                <span class="n">factor_base</span> <span class="o">=</span> <span class="n">factor</span>
                <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span>
                <span class="n">replacements</span> <span class="o">=</span> <span class="p">[</span><span class="n">Exp</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">power_of_one_reduction</span><span class="p">()]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">factor_base</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
                <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="p">(</span>
                        <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">factor</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
                <span class="n">replacements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">replacements</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Factor a or a^c from a^b.</span>
                <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;right&#39;</span><span class="p">:</span>
                    <span class="n">_c</span><span class="p">,</span> <span class="n">_d</span> <span class="o">=</span> <span class="n">_d</span><span class="p">,</span> <span class="n">_c</span>
                <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">exp_factored_real</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_d</span><span class="p">},</span>
                            <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
                <span class="k">elif</span> <span class="n">RealNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                      <span class="n">Integer</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">exp_factored_int</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">_d</span><span class="p">},</span>
                            <span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UnsatisfiedPrerequisites</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not readily provable to be a positive &quot;</span>
                            <span class="s2">&quot;number, or a nonzero real with </span><span class="si">%s</span><span class="s2"> as an &quot;</span>
                            <span class="s2">&quot;integer in order to enable the factorization &quot;</span>
                            <span class="s2">&quot;of </span><span class="si">%s</span><span class="s2">.&quot;</span>
                            <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            
            <span class="n">factor_base</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">readily_factorable</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
                <span class="n">factor_base</span> <span class="o">=</span> <span class="n">factor</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
                <span class="n">factor_base</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span>
            
            <span class="k">if</span> <span class="n">factor_base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">readily_factorable</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">factor_base</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">UnsatisfiedPrerequisites</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not readily factorable from </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            
            <span class="c1"># Factor within the base. For example,</span>
            <span class="c1"># a = b*c</span>
            <span class="c1"># a^d = (b^d) * (c^d) = b^e * b^(e-d) * c^d</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                <span class="n">factor_base</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span> <span class="n">group_factors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="c1"># distribute: (b^d) * (c^d)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">distribution</span><span class="p">(</span>
                    <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">num_entries</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">factor</span><span class="o">==</span><span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="c1"># e.g., a^c factored out of (a*b)^c</span>
                <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>
            <span class="c1"># factor portion: (b^e * b^(e-d)) * c^d</span>
            <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">inner_expr</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inner_expr</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span>
                                <span class="n">factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="n">pull</span><span class="p">,</span>
                                <span class="n">group_factors</span><span class="o">=</span><span class="n">group_factors</span><span class="p">,</span> 
                                <span class="n">group_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="c1"># disassociate: b^e * b^(e-d) * c^d</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">disassociation</span><span class="p">(</span>
                    <span class="n">idx</span><span class="p">,</span> <span class="n">preserve_all</span><span class="o">=</span><span class="n">group_remainder</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">group_remainder</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">association</span><span class="p">(</span>
                        <span class="mi">0</span> <span class="k">if</span> <span class="n">pull</span><span class="o">==</span><span class="s1">&#39;right&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="n">num_entries</span><span class="p">,</span>
                        <span class="n">num_entries</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">relation</span>

<div class="viewcode-block" id="Exp.distribution"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.distribution">[docs]</a>    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;distributed&#39;</span><span class="p">,</span> <span class="s1">&#39;distribute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Equate this exponential to a form in which the exponent</span>
<span class="sd">        is distributed over factors, or a power of a power reduces to</span>
<span class="sd">        a power of multiplied exponents.</span>
<span class="sd">        Examples:</span>
<span class="sd">            (a*b*c)^f = a^f * b^f * c^f</span>
<span class="sd">            (a/b)^f = (a^f / b^f)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">Div</span><span class="p">,</span> <span class="n">NaturalPos</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">Real</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">as</span> <span class="nn">exp_pkg</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="n">exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Mult</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">num_elements</span><span class="p">()</span>
                <span class="n">_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span>
            <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">posnat_power_of_product</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">posnat_power_of_products</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span> <span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">pos_power_of_product</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">pos_power_of_products</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span> <span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">real_power_of_product</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">real_power_of_products</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span> <span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Complex is the default</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">complex_power_of_product</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">complex_power_of_products</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">m</span><span class="p">:</span> <span class="n">_m</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Div</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span><span class="o">.</span><span class="n">is_double</span><span class="p">()</span>
            <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">operands</span>
            <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">posnat_power_of_quotient</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">pos_power_of_quotient</span>
                <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">real_power_of_quotient</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Complex is the default</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">complex_power_of_quotient</span>
                <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">exponent</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Nothing to distribute over.</span>
            <span class="k">return</span> <span class="n">Equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conclude_via_reflexivity</span><span class="p">()</span></div>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;double_exponent_reduced&#39;</span><span class="p">,</span> <span class="s1">&#39;double_exponent_reduce&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">double_exponent_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">NaturalPos</span><span class="p">,</span> <span class="n">RealPos</span><span class="p">,</span> <span class="n">Real</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">as</span> <span class="nn">exp_pkg</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="n">exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Exp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;double_exponent_reduction&#39; only applicable &quot;</span>
                             <span class="s2">&quot;when the &#39;base&#39; is an exponential, not for </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">base_exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span>
                <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        
        <span class="n">_a</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span>
        <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">NaturalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_exp_ns</span><span class="p">):</span>
                <span class="n">_m</span><span class="p">,</span> <span class="n">_n</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">exponent</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">posnat_power_of_posnat_power</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">_m</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">_n</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">exponent</span>
                <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_exp_ns</span><span class="p">):</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">pos_power_of_pos_power</span>
                <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_exp_ns</span><span class="p">):</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">real_power_of_real_power</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Complex is the default</span>
                    <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">complex_power_of_complex_power</span>
                <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_b</span><span class="p">,</span> <span class="n">_c</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">exponent</span>
            <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_exp_ns</span><span class="p">)):</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">pos_power_of_pos_power</span>
            <span class="k">elif</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_exp_ns</span><span class="p">)):</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">real_power_of_real_power</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Complex is the default</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">complex_power_of_complex_power</span>
            <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">_c</span><span class="p">})</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def distribute_exponent(self, assumptions=frozenset()):</span>
<span class="sd">        from proveit.numbers import Div</span>
<span class="sd">        from proveit.numbers.division.theorems import (</span>
<span class="sd">                frac_int_exp_rev, frac_nat_pos_exp_rev)</span>
<span class="sd">        if isinstance(self.base, Div):</span>
<span class="sd">            exponent = self.exponent</span>
<span class="sd">            try:</span>
<span class="sd">                deduce_in_natural_pos(exponent, assumptions)</span>
<span class="sd">                deduce_in_complex([self.base.numerator, self.base.denominator],</span>
<span class="sd">                                  assumptions)</span>
<span class="sd">                deduce_not_zero(self.base.denominator, assumptions)</span>
<span class="sd">                return frac_nat_pos_exp_rev.instantiate(</span>
<span class="sd">                        {n:exponent}).instantiate(</span>
<span class="sd">                            {a:self.numerator.base, b:self.denominator.base})</span>
<span class="sd">            except:</span>
<span class="sd">                deduce_in_integer(exponent, assumptions)</span>
<span class="sd">                deduce_in_complex([self.base.numerator, self.base.denominator],</span>
<span class="sd">                                  assumptions)</span>
<span class="sd">                deduce_not_zero(self.base.numerator, assumptions)</span>
<span class="sd">                deduce_not_zero(self.base.denominator, assumptions)</span>
<span class="sd">                return frac_int_exp_rev.instantiate(</span>
<span class="sd">                        {n:exponent}).instantiate(</span>
<span class="sd">                            {a:self.base.numerator, b:self.base.denominator})</span>
<span class="sd">        raise Exception(&#39;distribute_exponent currently only implemented for a &#39;</span>
<span class="sd">                        &#39;fraction base&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;exp_factorized&#39;</span><span class="p">,</span> <span class="s1">&#39;exp_factor&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">exp_factorization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exp_factor</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Pull out one of the exponent factors to an exponent at</span>
<span class="sd">        another level.  For example,</span>
<span class="sd">            a^{b*n} = (a^b)^n</span>
<span class="sd">            a^{-b*n} = (a^{-b})^n</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Note: this is out-of-date.  Distribution handles this now,</span>
        <span class="c1"># except it doesn&#39;t deal with the negation part</span>
        <span class="c1"># (do we need it to?)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">deduce_in_number_set</span><span class="p">,</span> <span class="n">Neg</span>
        <span class="c1"># from .theorems import int_exp_of_exp, int_exp_of_neg_exp</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">int_exp_of_exp</span><span class="p">,</span> <span class="n">int_exp_of_neg_exp</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Neg</span><span class="p">):</span>
            <span class="n">b_times_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">operand</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">int_exp_of_neg_exp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b_times_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
            <span class="n">thm</span> <span class="o">=</span> <span class="n">int_exp_of_exp</span>
        <span class="c1"># if not hasattr(b_times_c, &#39;factor&#39;):</span>
        <span class="c1">#     raise ValueError(&#39;Exponent not factorable, may not raise the &#39;</span>
        <span class="c1">#                      &#39;exponent factor.&#39;)</span>
        <span class="c1"># factor_eq = b_times_c.factor(exp_factor, pull=&#39;right&#39;,</span>
        <span class="c1">#                              group_remainder=True,</span>
        <span class="c1">#                              assumptions=assumptions)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b_times_c</span><span class="p">,</span> <span class="s1">&#39;factorization&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exponent </span><span class="si">{0}</span><span class="s1"> not factorable (for example, it &#39;</span>
                             <span class="s1">&#39;does not appear to be in the Mult class); may &#39;</span>
                             <span class="s1">&#39;not raise the exponent factor.&#39;</span><span class="o">.</span>
                             <span class="nb">format</span><span class="p">(</span><span class="n">b_times_c</span><span class="p">))</span>
        <span class="n">factor_eq</span> <span class="o">=</span> <span class="n">b_times_c</span><span class="o">.</span><span class="n">factorization</span><span class="p">(</span><span class="n">exp_factor</span><span class="p">,</span> <span class="n">pull</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>
                                     <span class="n">group_remainder</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">factor_eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">factor_eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
            <span class="c1"># factor the exponent first, then raise this exponent factor</span>
            <span class="n">factored_exp_eq</span> <span class="o">=</span> <span class="n">factor_eq</span><span class="o">.</span><span class="n">substitution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">factored_exp_eq</span><span class="o">.</span><span class="n">apply_transitivity</span><span class="p">(</span>
                <span class="n">factored_exp_eq</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">exp_factorization</span><span class="p">(</span><span class="n">exp_factor</span><span class="p">))</span>
        <span class="n">n_sub</span> <span class="o">=</span> <span class="n">b_times_c</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="n">b_sub</span> <span class="o">=</span> <span class="n">b_times_c</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># deduce_not_zero(a_sub, assumptions)</span>
        <span class="n">NotEquals</span><span class="p">(</span><span class="n">a_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        <span class="c1"># deduce_in_integer(n_sub, assumptions)</span>
        <span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">n_sub</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span>
        <span class="c1"># deduce_in_complex([a_sub, b_sub], assumptions)</span>
        <span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">a_sub</span><span class="p">,</span> <span class="n">Complex</span><span class="p">)</span>
        <span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">b_sub</span><span class="p">,</span> <span class="n">Complex</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">n_sub</span><span class="p">})</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
            <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">a_sub</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b_sub</span><span class="p">})</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">()</span>

    <span class="nd">@equality_prover</span><span class="p">(</span><span class="s1">&#39;exponent_separated&#39;</span><span class="p">,</span> <span class="s1">&#39;exponent_separate&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">exponent_separation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        From self of the form x^{a+b} deduce and return the equality</span>
<span class="sd">        x^{a+b} = x^a x^b. For example,</span>
<span class="sd">            Exp(x, Add(two, c)).split_exponent_sum()</span>
<span class="sd">        (with the apprpriate assumptions) should return:</span>
<span class="sd">            |- (x^{2+c}) =  x^2 x^c.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># among other things, convert any assumptions=None</span>
        <span class="c1"># to assumptions=()</span>
        <span class="c1"># assumptions = defaults.checkedAssumptions(assumptions)</span>

        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mult</span>

        <span class="c1"># implement only for the case in which exponent is an Add</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;Exp.exponent_separation()&#39; implemented only for cases in which &quot;</span>
            <span class="s2">&quot;the exponent appears as a sum (i.e. in the Add class). The &quot;</span>
            <span class="s2">&quot;exponent in this case is </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="c1"># list the addends in the exponent, which become exponents</span>
        <span class="n">the_exponents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">operands</span>

        <span class="c1"># list the new exponential factors</span>
        <span class="n">the_new_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">Exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">new_exp</span><span class="p">)</span> <span class="k">if</span> <span class="n">new_exp</span> <span class="o">!=</span> <span class="n">one</span>
                           <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="k">for</span> <span class="n">new_exp</span> <span class="ow">in</span> <span class="n">the_exponents</span><span class="p">]</span>

        <span class="c1"># create the new equivalent product (Mult)</span>
        <span class="n">mult_equiv</span> <span class="o">=</span> <span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="n">the_new_factors</span><span class="p">)</span>

        <span class="c1"># use the Mult.combining_exponents() to deduce equality to self</span>
        <span class="n">exp_separated</span> <span class="o">=</span> <span class="n">mult_equiv</span><span class="o">.</span><span class="n">combining_exponents</span><span class="p">(</span><span class="n">preserve_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">replacements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">replacements</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">auto_simplify</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Mult</span><span class="o">.</span><span class="n">temporary_simplification_directives</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp_directives</span><span class="p">:</span>
                <span class="c1"># Don&#39;t recombine the exponents after separating them.</span>
                <span class="n">tmp_directives</span><span class="o">.</span><span class="n">combine_all_exponents</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">tmp_directives</span><span class="o">.</span><span class="n">combine_numeric_rational_exponents</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">replacements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mult_equiv</span><span class="o">.</span><span class="n">shallow_simplification</span><span class="p">())</span>

        <span class="c1"># reverse the equality relationship and return</span>
        <span class="k">return</span> <span class="n">exp_separated</span><span class="o">.</span><span class="n">derive_reversed</span><span class="p">(</span><span class="n">replacements</span><span class="o">=</span><span class="n">replacements</span><span class="p">,</span>
                                             <span class="n">auto_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def lower_outer_exp(self, assumptions=frozenset()):</span>
<span class="sd">        #</span>
<span class="sd">        from proveit.numbers import Neg</span>
<span class="sd">        from .theorems import (</span>
<span class="sd">            int_exp_of_exp,</span>
<span class="sd">            int_exp_of_neg_exp,</span>
<span class="sd">            neg_int_exp_of_exp,</span>
<span class="sd">            neg_int_exp_of_neg_exp)</span>
<span class="sd">        if not isinstance(self.base, Exp):</span>
<span class="sd">            raise Exception(&#39;May only apply lower_outer_exp to nested &#39;</span>
<span class="sd">                            &#39;Exp operations&#39;)</span>
<span class="sd">        if isinstance(</span>
<span class="sd">                self.base.exponent,</span>
<span class="sd">                Neg) and isinstance(</span>
<span class="sd">                self.exponent,</span>
<span class="sd">                Neg):</span>
<span class="sd">            b_, n_ = self.base.exponent.operand, self.exponent.operand</span>
<span class="sd">            thm = neg_int_exp_of_neg_exp</span>
<span class="sd">        elif isinstance(self.base.exponent, Neg):</span>
<span class="sd">            b_, n_ = self.base.exponent.operand, self.exponent</span>
<span class="sd">            thm = int_exp_of_neg_exp</span>
<span class="sd">        elif isinstance(self.exponent, Neg):</span>
<span class="sd">            b_, n_ = self.base.exponent, self.exponent.operand</span>
<span class="sd">            thm = neg_int_exp_of_exp</span>
<span class="sd">        else:</span>
<span class="sd">            b_, n_ = self.base.exponent, self.exponent</span>
<span class="sd">            thm = int_exp_of_exp</span>
<span class="sd">        a_ = self.base.base</span>
<span class="sd">        deduce_not_zero(self.base.base, assumptions)</span>
<span class="sd">        deduce_in_integer(n_, assumptions)</span>
<span class="sd">        deduce_in_complex([a_, b_], assumptions)</span>
<span class="sd">        return thm.instantiate({n: n_}).instantiate({a: a_, b: b_})</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Exp.deduce_in_number_set"><a class="viewcode-back" href="../../../../api/proveit.numbers.Exp.html#proveit.numbers.Exp.deduce_in_number_set">[docs]</a>    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">deduce_in_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_set</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to prove that this exponentiation expression is in the</span>
<span class="sd">        given number set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>
        <span class="kn">import</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">as</span> <span class="nn">exp_pkg</span>

        <span class="k">if</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ZeroSet</span><span class="p">:</span>
            <span class="c1"># Prove 0^x in {0}; while we are at it, prove 0^x = 0.</span>
            <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exponentiated_zero</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_in_zero_set</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">NaturalPos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_natpos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Natural</span><span class="p">:</span>
            <span class="c1"># Use the NaturalPos closure which applies for</span>
            <span class="c1"># any Natural base and exponent.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">NaturalPos</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Natural</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_int_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Rational</span><span class="p">:</span>
            <span class="n">power_is_nat</span> <span class="o">=</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Natural</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">power_is_nat</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                <span class="c1"># Use the RationalNonZero closure which works</span>
                <span class="c1"># for negative exponents as well.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">RationalNonZero</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Rational</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_rational_closure_nat_power</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalNonZero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_rational_nonzero_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RationalPos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_rational_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Real</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrt_real_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">power_is_nat</span> <span class="o">=</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Natural</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">power_is_nat</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">():</span>
                    <span class="c1"># Use the RealPos closure which allows</span>
                    <span class="c1"># any real exponent but requires a</span>
                    <span class="c1"># non-negative base.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deduce_in_number_set</span><span class="p">(</span><span class="n">RealPos</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">InSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">prove</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_real_closure_nat_power</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealPos</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrt_real_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">two</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrd_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_real_pos_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">RealNonNeg</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrt_real_non_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">two</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrd_non_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_real_non_neg_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">Complex</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">sqrt_complex_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_complex_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">number_set</span> <span class="o">==</span> <span class="n">ComplexNonZero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp_pkg</span><span class="o">.</span><span class="n">exp_complex_nonzero_closure</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">})</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;Exp.deduce_in_number_set&#39; not implemented for the </span><span class="si">%s</span><span class="s2"> set&quot;</span>
            <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">number_set</span><span class="p">))</span></div>

    <span class="nd">@relation_prover</span>
    <span class="k">def</span> <span class="nf">bound_via_operand_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operand_relation</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For simple cases, deduce a bound on this Exp object given a</span>
<span class="sd">        bound on its operand. For example, suppose x = Exp(y, 2) and</span>
<span class="sd">        we know that y &gt;= 2. Then x.bound_via_operand_bound(y &gt;= 2)</span>
<span class="sd">        returns x &gt;= 2^2 = 4.</span>
<span class="sd">        This method currently works MAINLY for expressions</span>
<span class="sd">        of the form Exp(x, a) for non-negative real x and real exponent</span>
<span class="sd">        &#39;a&#39;, where we know something of the form x &lt; y (or x ≤ y, x &gt; y,</span>
<span class="sd">        x ≥ y) involving the base of the exponential expression.</span>
<span class="sd">        The result also depends on knowing the relationship between the</span>
<span class="sd">        exponent &#39;a&#39; and zero, which might need to be pre-proven or</span>
<span class="sd">        provided as an assumption (e.g. in the form &#39;a &gt; 0&#39; or</span>
<span class="sd">        InSet(a, RealNeg), etc).</span>
<span class="sd">        A special case also deals with a negative base raised to the</span>
<span class="sd">        power of 2.</span>
<span class="sd">        This method also works for special cases of the form Exp(a, x),</span>
<span class="sd">        where a &gt; 1 and the operand_relation involve the exponent x.</span>

<span class="sd">        Future development will address operand_relations</span>
<span class="sd">        involving the exponent x in expressions of the form a^x when</span>
<span class="sd">        the base 0 &lt; a &lt; 1, and expand the special negative</span>
<span class="sd">        base case to include all even and odd exponent cases.</span>
<span class="sd">        Also see NumberOperation.deduce_bound and compare to the</span>
<span class="sd">        bound_via_operand_bound() method found in the Div and Neg</span>
<span class="sd">        classes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit</span> <span class="k">import</span> <span class="n">Judgment</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="p">(</span>
                <span class="n">two</span><span class="p">,</span> <span class="n">greater</span><span class="p">,</span> <span class="n">greater_eq</span><span class="p">,</span> <span class="n">Less</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">,</span>
                <span class="n">NumberOrderingRelation</span><span class="p">,</span> <span class="n">RealNonNeg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Judgment</span><span class="p">):</span>
            <span class="n">operand_relation</span> <span class="o">=</span> <span class="n">operand_relation</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">NumberOrderingRelation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &quot;</span>
                    <span class="s2">&quot;&#39;operand_relation&#39; argument is expected to be a number &quot;</span>
                    <span class="s2">&quot;relation (&lt;, &gt;, ≤, or ≥), but instead was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

        <span class="n">lhs</span> <span class="o">=</span> <span class="n">operand_relation</span><span class="o">.</span><span class="n">lhs</span>
        <span class="c1"># should be able to generalize this later</span>
        <span class="c1"># no need to limit to just lhs, right?</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="ow">and</span> <span class="n">lhs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;In Exp.bound_via_operand_bound(), the left side of &quot;</span>
                    <span class="s2">&quot;the &#39;operand_relation&#39; argument </span><span class="si">{0}</span><span class="s2"> is expected to &quot;</span>
                    <span class="s2">&quot;match either the Exp base operand </span><span class="si">{1}</span><span class="s2"> or the &quot;</span>
                    <span class="s2">&quot;Exp exponent operand </span><span class="si">{2}</span><span class="s2">.&quot;</span><span class="o">.</span>
                    <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="c1"># assign x and y subs according to std Less or LessEq relations</span>
        <span class="n">_x_sub</span> <span class="o">=</span> <span class="n">operand_relation</span><span class="o">.</span><span class="n">normal_lhs</span>
        <span class="n">_y_sub</span> <span class="o">=</span> <span class="n">operand_relation</span><span class="o">.</span><span class="n">normal_rhs</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
            <span class="n">_a_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_a_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>

        <span class="c1"># I. Default case: the user-supplied operand relation involves</span>
        <span class="c1">#    the BASE of the Exp expression x^a</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>

            <span class="c1"># Several cases to consider:</span>
            <span class="c1">#  (1) a &gt; 0, 0 ≤ x &lt; y</span>
            <span class="c1">#  (2) a &gt; 0, 0 ≤ x ≤ y</span>
            <span class="c1">#  (3) a ≥ 0, 0 &lt; x &lt; y</span>
            <span class="c1">#  (4) a ≥ 0, 0 &lt; x ≤ y</span>
            <span class="c1">#  (5) a &lt; 0, 0 &lt; x &lt; y</span>
            <span class="c1">#  (6) a &lt; 0, 0 &lt; x ≤ y</span>
            <span class="c1">#  (7) a ≤ 0, 0 &lt; x &lt; y</span>
            <span class="c1">#  (8) a ≤ 0, 0 &lt; x ≤ y</span>
            <span class="c1"># =====================</span>
            <span class="c1">#  (9) a = 2, y &lt; x &lt; 0</span>
            <span class="c1"># (10) a = 2, y ≤ x &lt; 0</span>

            <span class="c1"># Cases (1) and (2): exponent a &gt; 0</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">greater_eq</span><span class="p">(</span><span class="n">_x_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_pos_less</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_pos_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_pos_lesseq</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_pos_lesseq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

            <span class="c1"># Cases (3) and (4): exponent a ≥ 0</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">greater_eq</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">greater</span><span class="p">(</span><span class="n">_x_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_nonneg_less</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_nonneg_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_nonneg_lesseq</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_nonneg_lesseq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

            <span class="c1"># Cases (5) and (6): exponent a &lt; 0</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">Less</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">greater</span><span class="p">(</span><span class="n">_x_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_neg_less</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_neg_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_neg_lesseq</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_neg_lesseq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

            <span class="c1"># Cases (7) and (8): exponent a ≤ 0</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">LessEq</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">greater</span><span class="p">(</span><span class="n">_x_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_nonpos_less</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_nonpos_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="n">exp_nonpos_lesseq</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_nonpos_lesseq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

            <span class="c1"># Cases (9) and (10): exponent a = 2</span>
            <span class="c1"># with x &lt; y &lt; 0 or x ≤ y &lt; 0</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">_a_sub</span> <span class="o">==</span> <span class="n">two</span> <span class="ow">and</span>
                <span class="n">Less</span><span class="p">(</span><span class="n">_y_sub</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                            <span class="n">exp_even_neg_base_less</span><span class="p">)</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_even_neg_base_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                            <span class="n">exp_even_neg_base_lesseq</span><span class="p">)</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_even_neg_base_lesseq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;In calling Exp.bound_via_operand_bound(), a &quot;</span>
                        <span class="s2">&quot;specific matching case was not found for </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># II. 2nd main case: the user-supplied operand relation involves</span>
        <span class="c1">#    the EXPONENT of the Exp expression a^x</span>
        <span class="k">elif</span> <span class="n">lhs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">:</span>

            <span class="c1"># Several cases to consider (others to be developed)</span>
            <span class="c1"># considering the Exp expression a^x with a, x in Real:</span>
            <span class="c1">#  (1) a &gt; 1, x &lt; y</span>
            <span class="c1">#  (2) a &gt; 1, x ≤ y</span>
            <span class="c1">#  (3) a &gt; 1, y &lt; x</span>
            <span class="c1">#  (4) a &gt; 1, y ≤ x</span>
            <span class="c1"># Other cases to be developed involving base a &lt; 1,</span>
            <span class="c1"># which produces a monotonically-decreasing function.</span>

            <span class="c1"># Cases (1)-(4): base a &gt; 1, a^x monotonically increasing</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">InSet</span><span class="p">(</span><span class="n">_x_sub</span><span class="p">,</span> <span class="n">Real</span><span class="p">)</span><span class="o">.</span><span class="n">readily_provable</span><span class="p">()):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">Less</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                            <span class="n">exp_monotonicity_large_base_less</span><span class="p">)</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_monotonicity_large_base_less</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">,</span> <span class="n">LessEq</span><span class="p">):</span>
                    <span class="kn">from</span> <span class="nn">proveit.numbers.exponentiation</span> <span class="k">import</span> <span class="p">(</span>
                        <span class="n">exp_monotonicity_large_base_less_eq</span><span class="p">)</span>
                    <span class="n">bound</span> <span class="o">=</span> <span class="n">exp_monotonicity_large_base_less_eq</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">_x_sub</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">_y_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">_a_sub</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), the &#39;operand_relation&#39; &quot;</span>
                        <span class="s2">&quot;argument is expected to be a &#39;Less&#39;, &#39;LessEq&#39;, &#39;greater&#39;, &quot;</span>
                        <span class="s2">&quot;or &#39;greater_eq&#39; relation. Instead we have </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">operand_relation</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;In Exp.bound_via_operand_bound(), either the &quot;</span>
                        <span class="s2">&quot;base </span><span class="si">{0}</span><span class="s2"> is not known to be greater than 1 and/or &quot;</span>
                        <span class="s2">&quot;the operand </span><span class="si">{1}</span><span class="s2"> is not known to be Real.&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">_a_sub</span><span class="p">,</span> <span class="n">_x_sub</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;OOOPS!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bound</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bound</span><span class="o">.</span><span class="n">with_direction_reversed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bound</span>

    <span class="k">def</span> <span class="nf">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the most restrictive number set we can readily</span>
<span class="sd">        prove contains the evaluation of this number operation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">base_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="n">exp_ns</span> <span class="o">=</span> <span class="n">readily_provable_number_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">Complex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">base_ns</span> <span class="o">==</span> <span class="n">ZeroSet</span> <span class="ow">and</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
            <span class="c1"># 0^x = 0 for x &gt; 0.</span>
            <span class="k">return</span> <span class="n">ZeroSet</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="o">==</span><span class="n">two</span><span class="p">:</span>
            <span class="c1"># Squaring is handled as a special case, but we should</span>
            <span class="c1"># extend this to all ven powers.</span>
            <span class="k">if</span> <span class="n">IntegerNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">NaturalPos</span>
            <span class="k">if</span> <span class="n">Integer</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Natural</span>
            <span class="k">if</span> <span class="n">RationalNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">RationalPos</span>
            <span class="k">if</span> <span class="n">Rational</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">RationalNonNeg</span>
            <span class="k">if</span> <span class="n">RealNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">RealPos</span>
            <span class="k">if</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">RealNonNeg</span>
        <span class="k">if</span> <span class="n">Natural</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Natural</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">NaturalPos</span>
        <span class="k">if</span> <span class="n">Integer</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Natural</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Integer</span>
        <span class="k">if</span> <span class="n">RationalPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Integer</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">RationalPos</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">RationalNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">Integer</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">RationalNonZero</span>
        <span class="k">if</span> <span class="n">Rational</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Natural</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">Rational</span>
        <span class="k">if</span> <span class="n">RealPos</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RealPos</span>
        <span class="k">if</span> <span class="n">RealNonNeg</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">RealNonNeg</span>
        <span class="k">if</span> <span class="n">Real</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Natural</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">exp_ns</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Real</span>
        <span class="k">if</span> <span class="n">ComplexNonZero</span><span class="o">.</span><span class="n">readily_includes</span><span class="p">(</span><span class="n">base_ns</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ComplexNonZero</span>
        <span class="k">return</span> <span class="n">Complex</span></div>


<span class="k">class</span> <span class="nc">ExpSetMembership</span><span class="p">(</span><span class="n">SetMembership</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Defines methods that apply to membership in an exponentiated set.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="n">SetMembership</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>

    <span class="nd">@prover</span>
    <span class="k">def</span> <span class="nf">conclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">defaults_config</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Attempt to conclude that the element is in the exponentiated set.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">proveit.logic</span> <span class="k">import</span> <span class="n">InSet</span>
        <span class="kn">from</span> <span class="nn">proveit.logic.sets.membership</span> <span class="k">import</span> <span class="p">(</span>
            <span class="n">exp_set_0</span><span class="p">,</span> <span class="n">exp_set_1</span><span class="p">,</span> <span class="n">exp_set_2</span><span class="p">,</span> <span class="n">exp_set_3</span><span class="p">,</span> <span class="n">exp_set_4</span><span class="p">,</span> <span class="n">exp_set_5</span><span class="p">,</span>
            <span class="n">exp_set_6</span><span class="p">,</span> <span class="n">exp_set_7</span><span class="p">,</span> <span class="n">exp_set_8</span><span class="p">,</span> <span class="n">exp_set_9</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">zero</span><span class="p">,</span> <span class="n">is_numeric_int</span><span class="p">,</span> <span class="n">DIGITS</span>
        <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">elem_in_set</span> <span class="o">=</span> <span class="n">InSet</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ExprTuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span>
                <span class="n">elem_in_set</span><span class="p">,</span> <span class="n">defaults</span><span class="o">.</span><span class="n">assumptions</span><span class="p">,</span>
                <span class="s2">&quot;Can only automatically deduce membership in exponentiated &quot;</span>
                <span class="s2">&quot;sets for an element that is a list&quot;</span><span class="p">)</span>
        <span class="n">exponent_eval</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">exponent</span><span class="o">.</span><span class="n">evaluation</span><span class="p">()</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">exponent_eval</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">base</span>
        <span class="k">if</span> <span class="n">is_numeric_int</span><span class="p">(</span><span class="n">exponent</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exp_set_0</span><span class="o">.</span><span class="n">instantiate</span><span class="p">({</span><span class="n">S</span><span class="p">:</span> <span class="n">base</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span> <span class="o">!=</span> <span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span>
                    <span class="n">elem_in_set</span><span class="p">,</span> <span class="n">defaults</span><span class="o">.</span><span class="n">assumptions</span><span class="p">,</span>
                    <span class="s2">&quot;Element not a member of the exponentiated set; &quot;</span>
                    <span class="s2">&quot;incorrect list length&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">exponent</span> <span class="ow">in</span> <span class="n">DIGITS</span><span class="p">:</span>
                <span class="c1"># thm = forall_S forall_{a, b... in S} (a, b, ...) in S^n</span>
                <span class="n">thm</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;exp_set_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">exponent</span><span class="o">.</span><span class="n">as_int</span><span class="p">()]</span>
                <span class="n">expr_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="p">:</span> <span class="n">base</span><span class="p">}</span>  <span class="c1"># S is the base</span>
                <span class="c1"># map a, b, ... to the elements of element.</span>
                <span class="n">expr_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">proveit</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span>
                    <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">_k</span><span class="p">)):</span> <span class="n">elem_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">elem_k</span>
                    <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">element</span><span class="p">)})</span>
                <span class="n">elem_in_set</span> <span class="o">=</span> <span class="n">thm</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">expr_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span>
                    <span class="n">elem_in_set</span><span class="p">,</span> <span class="n">defaults</span><span class="o">.</span><span class="n">assumptions</span><span class="p">,</span>
                    <span class="s2">&quot;Automatic deduction of membership in exponentiated sets &quot;</span>
                    <span class="s2">&quot;is not supported beyond an exponent of 9&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ProofFailure</span><span class="p">(</span>
                <span class="n">elem_in_set</span><span class="p">,</span> <span class="n">defaults</span><span class="o">.</span><span class="n">assumptions</span><span class="p">,</span>
                <span class="s2">&quot;Automatic deduction of membership in exponentiated sets is &quot;</span>
                <span class="s2">&quot;only supported for an exponent that is a literal integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exponent_eval</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">exponent_eval</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
            <span class="c1"># after proving that the element is in the set taken to</span>
            <span class="c1"># the evaluation of the exponent, substitute back in the</span>
            <span class="c1"># original exponent.</span>
            <span class="k">return</span> <span class="n">exponent_eval</span><span class="o">.</span><span class="n">sub_left_side_into</span><span class="p">(</span><span class="n">elem_in_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elem_in_set</span>

    <span class="k">def</span> <span class="nf">side_effects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">judgment</span><span class="p">):</span>
        <span class="k">return</span>
        <span class="k">yield</span>

<span class="c1"># outside any specific class:</span>
<span class="c1"># special Exp case of square root</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">e</span> <span class="c1"># Euler&#39;s number</span>
    <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">exponent</span><span class="p">,</span> <span class="n">styles</span><span class="o">=</span><span class="n">styles</span><span class="p">)</span>

<div class="viewcode-block" id="exp2pi_i"><a class="viewcode-back" href="../../../../api/proveit.numbers.exp2pi_i.html#proveit.numbers.exp2pi_i">[docs]</a><span class="k">def</span> <span class="nf">exp2pi_i</span><span class="p">(</span><span class="o">*</span><span class="n">exp_factors</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">proveit.numbers</span> <span class="k">import</span> <span class="n">Mult</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">Mult</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">two</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp_factors</span><span class="p">)))</span></div>

<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../../api/proveit.numbers.sqrt.html#proveit.numbers.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Special function for square root version of an exponential.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">frac</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">))</span></div>

<div class="viewcode-block" id="sqrd"><a class="viewcode-back" href="../../../../api/proveit.numbers.sqrd.html#proveit.numbers.sqrd">[docs]</a><span class="k">def</span> <span class="nf">sqrd</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Special function for squaring root version of an exponential.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">Exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">two</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Prove-It</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expression.html">as_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.as_expressions.html">as_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_equality_prover.html">auto_equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_prover.html">auto_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.auto_relation_prover.html">auto_relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.bundle.html">bundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.composite_expression.html">composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.equality_prover.html">equality_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.expression_depth.html">expression_depth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.extract_var_tuple_indices.html">extract_var_tuple_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_var_ranges.html">free_var_ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.free_vars.html">free_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.generate_inner_expressions.html">generate_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.horiz_var_array.html">horiz_var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced.html">maybe_fenced</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_latex.html">maybe_fenced_latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.maybe_fenced_string.html">maybe_fenced_string</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.prover.html">prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.relation_prover.html">relation_prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.reset.html">reset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_default_or_dummy_var.html">safe_default_or_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_var.html">safe_dummy_var</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.safe_dummy_vars.html">safe_dummy_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_index.html">simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.simplified_indices.html">simplified_indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.single_or_composite_expression.html">single_or_composite_expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.total_ordering.html">total_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.traverse_inner_expressions.html">traverse_inner_expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.unbundle.html">unbundle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_literals.html">used_literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.used_vars.html">used_vars</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_array.html">var_array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.var_range.html">var_range</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.vert_var_array.html">vert_var_array</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ArgumentExtractionError.html">ArgumentExtractionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Assumption.html">Assumption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Axiom.html">Axiom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composite.html">Composite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Composition.html">Composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Conditional.html">Conditional</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ConditionalSet.html">ConditionalSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Deduction.html">Deduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.DuplicateLiteralError.html">DuplicateLiteralError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprArray.html">ExprArray</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprRange.html">ExprRange</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTuple.html">ExprTuple</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ExprTupleError.html">ExprTupleError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Expression.html">Expression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Function.html">Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Generalization.html">Generalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.GeneralizationFailure.html">GeneralizationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ImproperReplacement.html">ImproperReplacement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.IndexedVar.html">IndexedVar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExpr.html">InnerExpr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InnerExprGenerator.html">InnerExprGenerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Instantiation.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InstantiationFailure.html">InstantiationFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.InvalidAssumptions.html">InvalidAssumptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Judgment.html">Judgment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Label.html">Label</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Lambda.html">Lambda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.LambdaApplicationError.html">LambdaApplicationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Literal.html">Literal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.MakeNotImplemented.html">MakeNotImplemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonens.html">ModusPonens</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ModusPonensFailure.html">ModusPonensFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.NamedExprs.html">NamedExprs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationError.html">OperationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.OperationOverInstances.html">OperationOverInstances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterCollisionError.html">ParameterCollisionError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterMaskingError.html">ParameterMaskingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ParameterRelabelingError.html">ParameterRelabelingError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Proof.html">Proof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.ProofFailure.html">ProofFailure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.RangeInstanceError.html">RangeInstanceError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.SimplificationDirectives.html">SimplificationDirectives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.StyleOptions.html">StyleOptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theorem.html">Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Theory.html">Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryException.html">TheoryException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TheoryPackage.html">TheoryPackage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransRelUpdater.html">TransRelUpdater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitiveRelation.html">TransitiveRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.TransitivityException.html">TransitivityException</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnsatisfiedPrerequisites.html">UnsatisfiedPrerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.UnusableProof.html">UnusableProof</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.Variable.html">Variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.VertExprArray.html">VertExprArray</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.core_expr_types.Len.html">Len</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.compose.html">compose</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.conclude_via_implication.html">conclude_via_implication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.deduce_equal_or_not.html">deduce_equal_or_not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_falsehood.html">evaluate_falsehood</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluate_truth.html">evaluate_truth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.evaluation_or_simplification.html">evaluation_or_simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.in_bool.html">in_bool</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.is_irreducible_value.html">is_irreducible_value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_proper_superset.html">not_proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.not_superset_eq.html">not_superset_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.proper_superset.html">proper_superset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.superset_eq.html">superset_eq</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.And.html">And</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Bijections.html">Bijections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.BooleanSet.html">BooleanSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Card.html">Card</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartExp.html">CartExp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.CartProd.html">CartProd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassMembership.html">ClassMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ClassNonmembership.html">ClassNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Difference.html">Difference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Disjoint.html">Disjoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Distinct.html">Distinct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Equals.html">Equals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.EvaluationError.html">EvaluationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Exists.html">Exists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.FalseLiteral.html">FalseLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Forall.html">Forall</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Iff.html">Iff</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Implies.html">Implies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InClass.html">InClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InSet.html">InSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Injections.html">Injections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Intersect.html">Intersect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IntersectAll.html">IntersectAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.InvImage.html">InvImage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.IrreducibleValue.html">IrreducibleValue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Not.html">Not</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotEquals.html">NotEquals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotExists.html">NotExists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInClass.html">NotInClass</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotInSet.html">NotInSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotProperSubset.html">NotProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.NotSubsetEq.html">NotSubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Or.html">Or</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.PowerSet.html">PowerSet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.ProperSubset.html">ProperSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Set.html">Set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetEquiv.html">SetEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetMembership.html">SetMembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNonmembership.html">SetNonmembership</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetNotEquiv.html">SetNotEquiv</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SetOfAll.html">SetOfAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SimplificationError.html">SimplificationError</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.StrictSubset.html">StrictSubset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetEq.html">SubsetEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.SubsetProper.html">SubsetProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Surjections.html">Surjections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.TrueLiteral.html">TrueLiteral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.Union.html">Union</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UnionAll.html">UnionAll</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.logic.UniqueExists.html">UniqueExists</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.complex_polar_coordinates.html">complex_polar_coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_fraction.html">compose_fraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.compose_product.html">compose_product</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_as_mon_dec_func.html">deduce_as_mon_dec_func</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_in_number_set.html">deduce_in_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_not_equal_numeric_rationals.html">deduce_not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.deduce_number_set.html">deduce_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_add.html">dist_add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.dist_subtract.html">dist_subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.exp2pi_i.html">exp2pi_i</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.frac.html">frac</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater.html">greater</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.greater_eq.html">greater_eq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_int.html">is_numeric_int</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_natural.html">is_numeric_natural</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.is_numeric_rational.html">is_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_ints.html">less_eq_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_eq_numeric_rationals.html">less_eq_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_ints.html">less_numeric_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.less_numeric_rationals.html">less_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.negated.html">negated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.not_equal_numeric_rationals.html">not_equal_numeric_rationals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.num.html">num</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.number_ordering.html">number_ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.numeric_rational_ints.html">numeric_rational_ints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.quick_simplified_index.html">quick_simplified_index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_factorable.html">readily_factorable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.readily_provable_number_set.html">readily_provable_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.remove_common_factors.html">remove_common_factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.simplified_numeric_rational.html">simplified_numeric_rational</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrd.html">sqrd</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.sqrt.html">sqrt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.standard_number_set.html">standard_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.subtract.html">subtract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.union_number_set.html">union_number_set</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.unit_length_complex_polar_angle.html">unit_length_complex_polar_angle</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Abs.html">Abs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Add.html">Add</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.BinarySequence.html">BinarySequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Ceil.html">Ceil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Conjugate.html">Conjugate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DecimalSequence.html">DecimalSequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Div.html">Div</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Divides.html">Divides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.DividesProper.html">DividesProper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Exp.html">Exp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Floor.html">Floor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.GCD.html">GCD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Integrate.html">Integrate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Interval.html">Interval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCC.html">IntervalCC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalCO.html">IntervalCO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOC.html">IntervalOC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.IntervalOO.html">IntervalOO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.KroneckerDelta.html">KroneckerDelta</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Less.html">Less</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.LessEq.html">LessEq</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Log.html">Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Max.html">Max</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Min.html">Min</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mod.html">Mod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.ModAbs.html">ModAbs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.MonDecFuncs.html">MonDecFuncs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Mult.html">Mult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Neg.html">Neg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOperation.html">NumberOperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.NumberOrderingRelation.html">NumberOrderingRelation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Numeral.html">Numeral</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Prod.html">Prod</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.RealInterval.html">RealInterval</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Round.html">Round</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/proveit.numbers.Sum.html">Sum</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  <li><a href="../../../proveit.html">proveit</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Wayne Witzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>